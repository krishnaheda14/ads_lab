WAP to convert a given Infix expression into its equivalent Postfix expression and evaluate it using stack.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

struct Stack {
    int top;
    int capacity;
    int* array;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (int*)malloc(stack->capacity * sizeof(int));
    return stack;
}

int isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

int isFull(struct Stack* stack) {
    return stack->top == stack->capacity - 1;
}

void push(struct Stack* stack, int item) {
    if (isFull(stack)) return;
    stack->array[++stack->top] = item;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) return -1;
    return stack->array[stack->top--];
}

int peek(struct Stack* stack) {
    if (isEmpty(stack)) return -1;
    return stack->array[stack->top];
}

int precedence(char op) {
    switch(op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return -1;
    }
}

void infixToPostfix(char* infix, char* postfix) {
    struct Stack* stack = createStack(MAX_SIZE);
    int i, k;
    for (i = 0, k = -1; infix[i]; ++i) {
        if (isalnum(infix[i])) {
            postfix[++k] = infix[i];
        } else if (infix[i] == '(') {
            push(stack, infix[i]);
        } else if (infix[i] == ')') {
            while (!isEmpty(stack) && peek(stack) != '(') {
                postfix[++k] = pop(stack);
            }
            pop(stack);
        } else {
            while (!isEmpty(stack) && precedence(infix[i]) <= precedence(peek(stack))) {
                postfix[++k] = pop(stack);
            }
            push(stack, infix[i]);
        }
    }
    while (!isEmpty(stack)) {
        postfix[++k] = pop(stack);
    }
    postfix[++k] = '\0';
}

int evaluatePostfix(char* postfix) {
    struct Stack* stack = createStack(MAX_SIZE);
    int i, operand1, operand2;
    for (i = 0; postfix[i]; ++i) {
        if (isdigit(postfix[i])) {
            push(stack, postfix[i] - '0');
        } else {
            operand2 = pop(stack);
            operand1 = pop(stack);
            switch(postfix[i]) {
                case '+':
                    push(stack, operand1 + operand2);
                    break;
                case '-':
                    push(stack, operand1 - operand2);
                    break;
                case '*':
                    push(stack, operand1 * operand2);
                    break;
                case '/':
                    push(stack, operand1 / operand2);
                    break;
                case '^':
                    push(stack, operand1 ^ operand2);
                    break;
            }
        }
    }
    return pop(stack);
}

int main() {
    char infix[MAX_SIZE], postfix[MAX_SIZE];
    printf("Enter an infix expression: ");
    scanf("%s", infix);
    infixToPostfix(infix, postfix);
    printf("Postfix expression: %s\n", postfix);
    printf("Result: %d\n", evaluatePostfix(postfix));
    return 0;
}


       WAP to convert a given Infix expression into its equivalent Prefix expression and evaluate it using stack.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

struct Stack {
    int top;
    int capacity;
    char* array;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (char*)malloc(stack->capacity * sizeof(char));
    return stack;
}

int isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

int isFull(struct Stack* stack) {
    return stack->top == stack->capacity - 1;
}

void push(struct Stack* stack, char item) {
    if (isFull(stack)) return;
    stack->array[++stack->top] = item;
}

char pop(struct Stack* stack) {
    if (isEmpty(stack)) return -1;
    return stack->array[stack->top--];
}

char peek(struct Stack* stack) {
    if (isEmpty(stack)) return -1;
    return stack->array[stack->top];
}

int precedence(char op) {
    switch(op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return -1;
    }
}

void infixToPrefix(char* infix, char* prefix) {
    int len = strlen(infix);
    // Reverse the infix expression
    for (int i = 0; i < len / 2; ++i) {
        char temp = infix[i];
        infix[i] = infix[len - i - 1];
        infix[len - i - 1] = temp;
    }
    // Swap '(' and ')' and reverse the precedence of operators
    for (int i = 0; i < len; ++i) {
        if (infix[i] == '(')
            infix[i] = ')';
        else if (infix[i] == ')')
            infix[i] = '(';
    }
    struct Stack* stack = createStack(MAX_SIZE);
    int i, k;
    for (i = 0, k = -1; infix[i]; ++i) {
        if (isalnum(infix[i])) {
            prefix[++k] = infix[i];
        } else if (infix[i] == '(') {
            push(stack, infix[i]);
        } else if (infix[i] == ')') {
            while (!isEmpty(stack) && peek(stack) != '(') {
                prefix[++k] = pop(stack);
            }
            pop(stack);
        } else {
            while (!isEmpty(stack) && precedence(infix[i]) < precedence(peek(stack))) {
                prefix[++k] = pop(stack);
            }
            push(stack, infix[i]);
        }
    }
    while (!isEmpty(stack)) {
        prefix[++k] = pop(stack);
    }
    prefix[++k] = '\0';
    // Reverse the prefix expression to get the final result
    len = strlen(prefix);
    for (int i = 0; i < len / 2; ++i) {
        char temp = prefix[i];
        prefix[i] = prefix[len - i - 1];
        prefix[len - i - 1] = temp;
    }
}

int evaluatePrefix(char* prefix) {
    struct Stack* stack = createStack(MAX_SIZE);
    int i, operand1, operand2;
    for (i = 0; prefix[i]; ++i) {
        if (isdigit(prefix[i])) {
            push(stack, prefix[i] - '0');
        } else {
            operand1 = pop(stack);
            operand2 = pop(stack);
            switch(prefix[i]) {
                case '+':
                    push(stack, operand1 + operand2);
                    break;
                case '-':
                    push(stack, operand1 - operand2);
                    break;
                case '*':
                    push(stack, operand1 * operand2);
                    break;
                case '/':
                    push(stack, operand1 / operand2);
                    break;
                case '^':
                    push(stack, operand1 ^ operand2);
                    break;
            }
        }
    }
    return pop(stack);
}

int main() {
    char infix[MAX_SIZE], prefix[MAX_SIZE];
    printf("Enter an infix expression: ");
    scanf("%s", infix);
    infixToPrefix(infix, prefix);
    printf("Prefix expression: %s\n", prefix);
    printf("Result: %d\n", evaluatePrefix(prefix));
    return 0;
}


       WAP to implement two stack using array and perform following operations on it. A. PUSH, B. POP, C. StackFull D. StackeEmpty E. Display Stack.
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

struct TwoStacks {
    int top1; // Top index of the first stack
    int top2; // Top index of the second stack
    int array[MAX_SIZE]; // Array to store elements of both stacks
};

struct TwoStacks* createTwoStacks() {
    struct TwoStacks* stacks = (struct TwoStacks*)malloc(sizeof(struct TwoStacks));
    stacks->top1 = -1; // Initialize top index of the first stack
    stacks->top2 = MAX_SIZE; // Initialize top index of the second stack
    return stacks;
}

int isStack1Full(struct TwoStacks* stacks) {
    return stacks->top1 == stacks->top2 - 1;
}

int isStack2Full(struct TwoStacks* stacks) {
    return stacks->top2 == stacks->top1 + 1;
}

int isStack1Empty(struct TwoStacks* stacks) {
    return stacks->top1 == -1;
}

int isStack2Empty(struct TwoStacks* stacks) {
    return stacks->top2 == MAX_SIZE;
}

void push1(struct TwoStacks* stacks, int data) {
    if (isStack1Full(stacks)) {
        printf("Stack 1 overflow\n");
        return;
    }
    stacks->array[++stacks->top1] = data;
}

void push2(struct TwoStacks* stacks, int data) {
    if (isStack2Full(stacks)) {
        printf("Stack 2 overflow\n");
        return;
    }
    stacks->array[--stacks->top2] = data;
}

int pop1(struct TwoStacks* stacks) {
    if (isStack1Empty(stacks)) {
        printf("Stack 1 underflow\n");
        return -1;
    }
    return stacks->array[stacks->top1--];
}

int pop2(struct TwoStacks* stacks) {
    if (isStack2Empty(stacks)) {
        printf("Stack 2 underflow\n");
        return -1;
    }
    return stacks->array[stacks->top2++];
}

void displayStack1(struct TwoStacks* stacks) {
    if (isStack1Empty(stacks)) {
        printf("Stack 1 is empty\n");
        return;
    }
    printf("Stack 1: ");
    for (int i = stacks->top1; i >= 0; i--) {
        printf("%d ", stacks->array[i]);
    }
    printf("\n");
}

void displayStack2(struct TwoStacks* stacks) {
    if (isStack2Empty(stacks)) {
        printf("Stack 2 is empty\n");
        return;
    }
    printf("Stack 2: ");
    for (int i = stacks->top2; i < MAX_SIZE; i++) {
        printf("%d ", stacks->array[i]);
    }
    printf("\n");
}

void displayBothStacks(struct TwoStacks* stacks) {
    displayStack1(stacks);
    displayStack2(stacks);
}

int main() {
    struct TwoStacks* stacks = createTwoStacks();

    push1(stacks, 10);
    push1(stacks, 20);
    push1(stacks, 30);

    push2(stacks, 40);
    push2(stacks, 50);
    push2(stacks, 60);

    displayBothStacks(stacks);

    pop1(stacks);
    pop2(stacks);

    displayBothStacks(stacks);

    return 0;
}

PRIMS Matrix
#include<stdio.h>
#include<stdlib.h>

void prims(int [][10],int);
int FindMinDist(int [],int [],int);
void DisplayMST(int [],int [][10],int);

void prims(int G[][10],int V)
{
    int visited[10],distance[10],parent[10],u;
    for(int i=0;i<V;i++)
    {
        visited[i] = 0;
        distance[i] = 999;
        parent[i] = -1;
    }
    distance[0] = 0;
    for(int i=0;i<(V-1);i++)
    {
        i = FindMinDist(distance,visited,V);
        visited[u] = 1;
        for(int j=0;j<V;j++)
        {
            if(G[u][j] != 999 && visited[j] == 0 && distance[j]>G[u][j])
            {
                distance[j] = G[u][j];
                parent[j] = u;
            }
        }
    }
    DisplayMST(parent,G,V);
}

int FindMinDist(int distance[], int visited[],int V)
{
    int index,min = 999;
    for(int i=0;i<V;i++)
    {
        if(visited[i] == 0 && distance[i]<min)
        {
            min = distance[i];
            index = i;
        }
    }
    return index;
}

void DisplayMST(int parent[],int G[][10],int V)
{
    printf("\nPrim's MST, Edge \t weight\n");
    for(int i=0;i<V;i++)
    {
        printf("Edge: %d %d, weight:- %d",i,parent[i],G[i][parent[i]]);
    }
}

int main()
{
    int G[10][10],V,e,u,v,ch;
    printf("Enter number of vertex");
    scanf("%d",&V);
    for(int i=0;i<V;i++)
    {
        for(int j=0;j<V;j++)
            G[i][j] = 0;
    }
    printf("\nEnter number of edges");
    scanf("%d",&e);
    for(int i=0;i<e;i++)
    {
        printf("\nEnter Edge: ");
        scanf("%d%d",&u,&v);
        G[u][v] = G[v][u] = 1;
    }
    prims(G,V);
    return 0;
}

TBT Inorder
#include <stdio.h>
#include <stdlib.h>

// Node structure for the Inorder Threaded Binary Tree
typedef struct TBTNode {
    int data;
    struct TBTNode *left, *right;
    int ltag, rtag; // Tags to indicate if left and right pointers are threads
} TBTNode;

// Function to create a new node
TBTNode* createNode(int data) {
    TBTNode* newNode = (TBTNode*)malloc(sizeof(TBTNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    newNode->ltag = 1;
    newNode->rtag = 1;
    return newNode;
}

// Function to insert a node in the Inorder Threaded Binary Tree
TBTNode* insertNode(TBTNode* root, int data) {
    TBTNode *ptr = root, *parent = NULL;

    // Find the position where the new node will be inserted
    while (ptr != NULL) {
        if (data == ptr->data) {
            printf("Duplicate data not allowed.\n");
            return root;
        }
        parent = ptr;
        if (data < ptr->data) {
            if (ptr->ltag == 0)
                ptr = ptr->left;
            else
                break;
        } else {
            if (ptr->rtag == 0)
                ptr = ptr->right;
            else
                break;
        }
    }

    // Create the new node
    TBTNode* newNode = createNode(data);

    if (parent == NULL) {
        root = newNode;
        newNode->left = NULL;
        newNode->right = NULL;
    } else if (data < parent->data) {
        newNode->left = parent->left;
        newNode->right = parent;
        parent->ltag = 0;
        parent->left = newNode;
    } else {
        newNode->right = parent->right;
        newNode->left = parent;
        parent->rtag = 0;
        parent->right = newNode;
    }

    return root;
}

// Function to find the leftmost node in a tree/subtree
TBTNode* leftmost(TBTNode* node) {
    while (node != NULL && node->ltag == 0)
        node = node->left;
    return node;
}

// Function to perform inorder traversal of the Inorder Threaded Binary Tree
void inorderTraversal(TBTNode* root) {
    TBTNode* cur = leftmost(root);

    while (cur != NULL) {
        printf("%d ", cur->data);

        if (cur->rtag == 1)
            cur = cur->right;
        else
            cur = leftmost(cur->right);
    }
}

// Main function to execute the program
int main() {
    TBTNode* root = NULL;

    int n, data;
    printf("Enter number of nodes: ");
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        printf("Enter data for node %d: ", i + 1);
        scanf("%d", &data);
        root = insertNode(root, data);
    }

    printf("Inorder traversal of the Inorder Threaded Binary Tree:\n");
    inorderTraversal(root);

    return 0;
}

TBT Preorder
#include <stdio.h>
#include <stdlib.h>

// Node structure for the Inorder Threaded Binary Tree
typedef struct TBTNode {
    int data;
    struct TBTNode *left, *right;
    int ltag, rtag; // Tags to indicate if left and right pointers are threads
} TBTNode;

// Function to create a new node
TBTNode* createNode(int data) {
    TBTNode* newNode = (TBTNode*)malloc(sizeof(TBTNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    newNode->ltag = 1;
    newNode->rtag = 1;
    return newNode;
}

// Function to insert a node in the Inorder Threaded Binary Tree
TBTNode* insertNode(TBTNode* root, int data) {
    TBTNode *ptr = root, *parent = NULL;

    // Find the position where the new node will be inserted
    while (ptr != NULL) {
        if (data == ptr->data) {
            printf("Duplicate data not allowed.\n");
            return root;
        }
        parent = ptr;
        if (data < ptr->data) {
            if (ptr->ltag == 0)
                ptr = ptr->left;
            else
                break;
        } else {
            if (ptr->rtag == 0)
                ptr = ptr->right;
            else
                break;
        }
    }

    // Create the new node
    TBTNode* newNode = createNode(data);

    if (parent == NULL) {
        root = newNode;
        newNode->left = NULL;
        newNode->right = NULL;
    } else if (data < parent->data) {
        newNode->left = parent->left;
        newNode->right = parent;
        parent->ltag = 0;
        parent->left = newNode;
    } else {
        newNode->right = parent->right;
        newNode->left = parent;
        parent->rtag = 0;
        parent->right = newNode;
    }

    return root;
}

// Function to find the next node in preorder traversal
TBTNode* preorderSuccessor(TBTNode* node) {
    if (node->ltag == 0)
        return node->left;
    while (node->rtag == 1 && node->right != NULL)
        node = node->right;
    return node->right;
}

// Function to perform preorder traversal of the Inorder Threaded Binary Tree
void preorderTraversal(TBTNode* root) {
    if (root == NULL)
        return;

    TBTNode* cur = root;
    while (cur != NULL) {
        printf("%d ", cur->data);
        cur = preorderSuccessor(cur);
    }
}

// Main function to execute the program
int main() {
    TBTNode* root = NULL;

    int n, data;
    printf("Enter number of nodes: ");
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        printf("Enter data for node %d: ", i + 1);
        scanf("%d", &data);
        root = insertNode(root, data);
    }

    printf("Preorder traversal of the Inorder Threaded Binary Tree:\n");
    preorderTraversal(root);

    return 0;
}

Write a program to illustrate operations on a BST holding numeric keys. The menu must include: • Insert • Mirror Image       • Find • Height of the tree

#include <stdio.h>
#include <stdlib.h>

// Definition of the node structure
struct Node {
    int key;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a key into the BST
struct Node* insert(struct Node* node, int key) {
    if (node == NULL)
        return createNode(key);

    if (key < node->key)
        node->left = insert(node->left, key);
    else if (key > node->key)
        node->right = insert(node->right, key);

    return node;
}

// Function to create the mirror image of the BST
void mirror(struct Node* node) {
    if (node == NULL)
        return;

    struct Node* temp = node->left;
    node->left = node->right;
    node->right = temp;

    mirror(node->left);
    mirror(node->right);
}

// Function to find a key in the BST
struct Node* find(struct Node* node, int key) {
    if (node == NULL || node->key == key)
        return node;

    if (key < node->key)
        return find(node->left, key);
    else
        return find(node->right, key);
}

// Function to get the height of the BST
int height(struct Node* node) {
    if (node == NULL)
        return 0;
    else {
        int leftHeight = height(node->left);
        int rightHeight = height(node->right);
        return (leftHeight > rightHeight) ? (leftHeight + 1) : (rightHeight + 1);
    }
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Insert\n");
    printf("2. Mirror Image\n");
    printf("3. Find\n");
    printf("4. Height of the tree\n");
    printf("5. Exit\n");
    printf("Enter your choice: ");
}

// Function to perform in-order traversal of the BST
void inOrderTraversal(struct Node* root) {
    if (root != NULL) {
        inOrderTraversal(root->left);
        printf("%d ", root->key);
        inOrderTraversal(root->right);
    }
}

int main() {
    struct Node* root = NULL;
    int choice, key, numElements;

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the number of elements to insert: ");
                scanf("%d", &numElements);
                printf("Enter %d keys to insert:\n", numElements);
                for (int i = 0; i < numElements; i++) {
                    scanf("%d", &key);
                    root = insert(root, key);
                }
                break;
            case 2:
                mirror(root);
                printf("Mirror image of the tree:\n");
                inOrderTraversal(root);
                printf("\n");
                mirror(root); // Restore the original tree
                break;
            case 3:
                printf("Enter key to find: ");
                scanf("%d", &key);
                if (find(root, key) != NULL)
                    printf("Key %d found in the tree.\n", key);
                else
                    printf("Key %d not found in the tree.\n", key);
                break;
            case 4:
                printf("Height of the tree: %d\n", height(root));
                break;
            case 5:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}

 
 
 
 


Write a Program to create a Binary Tree and perform following Non-recursive operations on it. a. Postorder Traversal  c. Display Leaf Nodes d. Mirror Image
#include <stdio.h>
#include <stdlib.h>

// Structure of a binary tree node
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// Structure of a stack node (used for non-recursive traversal)
struct StackNode {
    struct TreeNode* treeNode;
    struct StackNode* next;
};

// Function to create a new tree node
struct TreeNode* createNode(int data) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to push a tree node onto the stack
void push(struct StackNode** top, struct TreeNode* treeNode) {
    struct StackNode* newNode = (struct StackNode*)malloc(sizeof(struct StackNode));
    newNode->treeNode = treeNode;
    newNode->next = *top;
    *top = newNode;
}

// Function to pop a tree node from the stack
struct TreeNode* pop(struct StackNode** top) {
    if (*top == NULL)
        return NULL;
    struct TreeNode* poppedNode = (*top)->treeNode;
    struct StackNode* temp = *top;
    *top = (*top)->next;
    free(temp);
    return poppedNode;
}

// Function to perform postorder traversal iteratively
void postOrderTraversal(struct TreeNode* root) {
    if (root == NULL)
        return;

    struct StackNode* stack = NULL;
    struct TreeNode* currNode = root;
    struct TreeNode* lastVisited = NULL;

    while (currNode || stack) {
        if (currNode) {
            push(&stack, currNode);
            currNode = currNode->left;
        } else {
            struct TreeNode* peekNode = stack->treeNode;
            if (peekNode->right && lastVisited != peekNode->right) {
                currNode = peekNode->right;
            } else {
                printf("%d ", peekNode->data);
                lastVisited = pop(&stack);
            }
        }
    }
}

// Function to display leaf nodes of the tree
void displayLeafNodes(struct TreeNode* root) {
    if (root == NULL)
        return;

    struct StackNode* stack = NULL;
    struct TreeNode* currNode = root;

    while (currNode || stack) {
        if (currNode) {
            push(&stack, currNode);
            currNode = currNode->left;
        } else {
            struct TreeNode* peekNode = stack->treeNode;
            if (peekNode->right == NULL && peekNode->left == NULL) {
                printf("%d ", peekNode->data);
            }
            pop(&stack);
            currNode = peekNode->right;
        }
    }
}

// Function to create the mirror image of the tree
void mirrorImage(struct TreeNode* root) {
    if (root == NULL)
        return;

    // Recursively mirror the left and right subtrees
    mirrorImage(root->left);
    mirrorImage(root->right);

    // Swap left and right children of current node
    struct TreeNode* temp = root->left;
    root->left = root->right;
    root->right = temp;
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Postorder Traversal\n");
    printf("2. Display Leaf Nodes\n");
    printf("3. Mirror Image\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct TreeNode* root = NULL;
    int choice, numElements, data;

    // Input number of elements and their values
    printf("Enter the number of elements to insert: ");
    scanf("%d", &numElements);
    printf("Enter %d elements to create the binary tree:\n", numElements);
    for (int i = 0; i < numElements; i++) {
        scanf("%d", &data);
        if (root == NULL) {
            root = createNode(data);
        } else {
            struct TreeNode* currentNode = root;
            while (1) {
                if (data <= currentNode->data) {
                    if (currentNode->left == NULL) {
                        currentNode->left = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->left;
                    }
                } else {
                    if (currentNode->right == NULL) {
                        currentNode->right = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->right;
                    }
                }
            }
        }
    }

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Postorder Traversal: ");
                postOrderTraversal(root);
                printf("\n");
                break;
            case 2:
                printf("Leaf Nodes: ");
                displayLeafNodes(root);
                printf("\n");
                break;
            case 3:
                printf("Mirror Image:\n");
                mirrorImage(root);
                postOrderTraversal(root);
                printf("\n");
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}

 
 

Write a Program to create a Binary Search Tree and perform following non-recursive operations on it. a. Inorder Traversal b. Display Number of Leaf Nodes c. Mirror Image
#include <stdio.h>
#include <stdlib.h>

// Structure of a binary tree node
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// Structure of a stack node (used for non-recursive traversal)
struct StackNode {
    struct TreeNode* treeNode;
    struct StackNode* next;
};

// Function to create a new tree node
struct TreeNode* createNode(int data) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to push a tree node onto the stack
void push(struct StackNode** top, struct TreeNode* treeNode) {
    struct StackNode* newNode = (struct StackNode*)malloc(sizeof(struct StackNode));
    newNode->treeNode = treeNode;
    newNode->next = *top;
    *top = newNode;
}

// Function to pop a tree node from the stack
struct TreeNode* pop(struct StackNode** top) {
    if (*top == NULL)
        return NULL;
    struct TreeNode* poppedNode = (*top)->treeNode;
    struct StackNode* temp = *top;
    *top = (*top)->next;
    free(temp);
    return poppedNode;
}

// Function to perform inorder traversal iteratively
void inOrderTraversal(struct TreeNode* root) {
    if (root == NULL)
        return;

    struct StackNode* stack = NULL;
    struct TreeNode* currNode = root;

    while (currNode || stack) {
        while (currNode) {
            push(&stack, currNode);
            currNode = currNode->left;
        }
        currNode = pop(&stack);
        printf("%d ", currNode->data);
        currNode = currNode->right;
    }
}

// Function to count the number of leaf nodes in the tree
int countLeafNodes(struct TreeNode* root) {
    if (root == NULL)
        return 0;

    int leafCount = 0;
    struct StackNode* stack = NULL;
    struct TreeNode* currNode = root;

    while (currNode || stack) {
        while (currNode) {
            push(&stack, currNode);
            currNode = currNode->left;
        }
        currNode = pop(&stack);
        if (currNode->left == NULL && currNode->right == NULL)
            leafCount++;
        currNode = currNode->right;
    }

    return leafCount;
}

// Function to create the mirror image of the tree
void mirrorImage(struct TreeNode* root) {
    if (root == NULL)
        return;

    // Iteratively mirror the left and right subtrees using stack
    struct StackNode* stack = NULL;
    push(&stack, root);

    while (stack) {
        struct TreeNode* currNode = pop(&stack);
        // Swap left and right children of the current node
        struct TreeNode* temp = currNode->left;
        currNode->left = currNode->right;
        currNode->right = temp;

        if (currNode->left)
            push(&stack, currNode->left);
        if (currNode->right)
            push(&stack, currNode->right);
    }
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Inorder Traversal\n");
    printf("2. Display Number of Leaf Nodes\n");
    printf("3. Mirror Image\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct TreeNode* root = NULL;
    int choice, numElements, data;

    // Input number of elements
    printf("Enter the number of elements to insert: ");
    scanf("%d", &numElements);

    // Input values to create the binary tree
    printf("Enter the elements to create the Binary Search Tree:\n");
    for (int i = 0; i < numElements; i++) {
        scanf("%d", &data);
        if (root == NULL) {
            root = createNode(data);
        } else {
            struct TreeNode* currentNode = root;
            while (1) {
                if (data < currentNode->data) {
                    if (currentNode->left == NULL) {
                        currentNode->left = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->left;
                    }
                } else {
                    if (currentNode->right == NULL) {
                        currentNode->right = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->right;
                    }
                }
            }
        }
    }

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Inorder Traversal: ");
                inOrderTraversal(root);
                printf("\n");
                break;
            case 2:
                printf("Number of Leaf Nodes: %d\n", countLeafNodes(root));
                break;
            case 3:
                printf("Mirror Image created.\n");
                mirrorImage(root);
                inOrderTraversal(root);
                printf("\n");
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}
 
 
 

Write a Program to create a Binary Search Tree and perform following non-recursive operations on it. a. Preorder Traversal b. Display total Number of Nodes C. Display Leaf nodes.
#include <stdio.h>
#include <stdlib.h>

// Structure of a binary tree node
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// Structure of a stack node (used for non-recursive traversal)
struct StackNode {
    struct TreeNode* treeNode;
    struct StackNode* next;
};

// Function to create a new tree node
struct TreeNode* createNode(int data) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to push a tree node onto the stack
void push(struct StackNode** top, struct TreeNode* treeNode) {
    struct StackNode* newNode = (struct StackNode*)malloc(sizeof(struct StackNode));
    newNode->treeNode = treeNode;
    newNode->next = *top;
    *top = newNode;
}

// Function to pop a tree node from the stack
struct TreeNode* pop(struct StackNode** top) {
    if (*top == NULL)
        return NULL;
    struct TreeNode* poppedNode = (*top)->treeNode;
    struct StackNode* temp = *top;
    *top = (*top)->next;
    free(temp);
    return poppedNode;
}

// Function to perform preorder traversal iteratively
void preOrderTraversal(struct TreeNode* root) {
    if (root == NULL)
        return;

    struct StackNode* stack = NULL;
    push(&stack, root);

    while (stack) {
        struct TreeNode* currNode = pop(&stack);
        printf("%d ", currNode->data);

        if (currNode->right)
            push(&stack, currNode->right);
        if (currNode->left)
            push(&stack, currNode->left);
    }
}

// Function to count the number of leaf nodes in the tree
int countLeafNodes(struct TreeNode* root) {
    if (root == NULL)
        return 0;

    int leafCount = 0;
    struct StackNode* stack = NULL;
    struct TreeNode* currNode = root;

    while (currNode || stack) {
        while (currNode) {
            push(&stack, currNode);
            currNode = currNode->left;
        }
        currNode = pop(&stack);
        if (currNode->left == NULL && currNode->right == NULL)
            leafCount++;
        currNode = currNode->right;
    }

    return leafCount;
}

// Function to create the mirror image of the tree
void mirrorImage(struct TreeNode* root) {
    if (root == NULL)
        return;

    // Iteratively mirror the left and right subtrees using stack
    struct StackNode* stack = NULL;
    push(&stack, root);

    while (stack) {
        struct TreeNode* currNode = pop(&stack);
        // Swap left and right children of the current node
        struct TreeNode* temp = currNode->left;
        currNode->left = currNode->right;
        currNode->right = temp;

        if (currNode->left)
            push(&stack, currNode->left);
        if (currNode->right)
            push(&stack, currNode->right);
    }
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Preorder Traversal\n");
    printf("2. Display Number of Leaf Nodes\n");
    printf("3. Mirror Image\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct TreeNode* root = NULL;
    int choice, numElements, data;

    // Input number of elements
    printf("Enter the number of elements to insert: ");
    scanf("%d", &numElements);

    // Input values to create the binary tree
    printf("Enter the elements to create the Binary Search Tree:\n");
    for (int i = 0; i < numElements; i++) {
        scanf("%d", &data);
        if (root == NULL) {
            root = createNode(data);
        } else {
            struct TreeNode* currentNode = root;
            while (1) {
                if (data < currentNode->data) {
                    if (currentNode->left == NULL) {
                        currentNode->left = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->left;
                    }
                } else {
                    if (currentNode->right == NULL) {
                        currentNode->right = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->right;
                    }
                }
            }
        }
    }

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Preorder Traversal: ");
                preOrderTraversal(root);
                printf("\n");
                break;
            case 2:
                printf("Number of Leaf Nodes: %d\n", countLeafNodes(root));
                break;
            case 3:
                printf("Mirror Image created.\n");
                mirrorImage(root);
                preOrderTraversal(root);
                printf("\n");
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}


 
 
 


Write a Program to create a Binary Search Tree and perform deletion of a node from it. Also display the tree in nonrecursive postorder way.
#include <stdio.h>
#include <stdlib.h>

// Structure of a binary tree node
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// Structure of a stack node (used for non-recursive traversal)
struct StackNode {
    struct TreeNode* treeNode;
    struct StackNode* next;
};

// Function to create a new tree node
struct TreeNode* createNode(int data) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to push a tree node onto the stack
void push(struct StackNode** top, struct TreeNode* treeNode) {
    struct StackNode* newNode = (struct StackNode*)malloc(sizeof(struct StackNode));
    newNode->treeNode = treeNode;
    newNode->next = *top;
    *top = newNode;
}

// Function to pop a tree node from the stack
struct TreeNode* pop(struct StackNode** top) {
    if (*top == NULL)
        return NULL;
    struct TreeNode* poppedNode = (*top)->treeNode;
    struct StackNode* temp = *top;
    *top = (*top)->next;
    free(temp);
    return poppedNode;
}

// Function to perform postorder traversal iteratively
void postOrderTraversal(struct TreeNode* root) {
    if (root == NULL)
        return;

    struct StackNode* stack1 = NULL;
    struct StackNode* stack2 = NULL;
    push(&stack1, root);

    while (stack1) {
        struct TreeNode* currNode = pop(&stack1);
        push(&stack2, currNode);

        if (currNode->left)
            push(&stack1, currNode->left);
        if (currNode->right)
            push(&stack1, currNode->right);
    }

    while (stack2) {
        printf("%d ", pop(&stack2)->data);
    }
}

// Function to insert a node into the BST
struct TreeNode* insert(struct TreeNode* root, int data) {
    if (root == NULL)
        return createNode(data);

    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);

    return root;
}

// Function to find the minimum value node in a subtree
struct TreeNode* minValueNode(struct TreeNode* node) {
    struct TreeNode* current = node;

    // Find the leftmost leaf node
    while (current && current->left != NULL)
        current = current->left;

    return current;
}

// Function to delete a node from the BST
struct TreeNode* deleteNode(struct TreeNode* root, int key) {
    if (root == NULL)
        return root;

    // If the key to be deleted is smaller than the root's key, then it lies in the left subtree
    if (key < root->data)
        root->left = deleteNode(root->left, key);

    // If the key to be deleted is greater than the root's key, then it lies in the right subtree
    else if (key > root->data)
        root->right = deleteNode(root->right, key);

    // If the key is same as root's key, then this is the node to be deleted
    else {
        // Node with only one child or no child
        if (root->left == NULL) {
            struct TreeNode* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct TreeNode* temp = root->left;
            free(root);
            return temp;
        }

        // Node with two children: Get the inorder successor (smallest in the right subtree)
        struct TreeNode* temp = minValueNode(root->right);

        // Copy the inorder successor's content to this node
        root->data = temp->data;

        // Delete the inorder successor
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Insert Element\n");
    printf("2. Delete Element\n");
    printf("3. Display Postorder Traversal\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct TreeNode* root = NULL;
    int choice, numElements, data, key;

    // Input number of elements
    printf("Enter the number of elements to insert: ");
    scanf("%d", &numElements);

    // Input values to create the binary search tree
    printf("Enter the elements to create the Binary Search Tree:\n");
    for (int i = 0; i < numElements; i++) {
        scanf("%d", &data);
        root = insert(root, data);
    }

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter element to insert: ");
                scanf("%d", &data);
                root = insert(root, data);
                break;
            case 2:
                printf("Enter element to delete: ");
                scanf("%d", &key);
                root = deleteNode(root, key);
                break;
            case 3:
                printf("Postorder Traversal: ");
                postOrderTraversal(root);
                printf("\n");
                break;
            case 4:
                exit (0);
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}

 
 

Write a Program to create a Binary Search Tree and display it levelwise. Also perform deletion of a node from it.
#include <stdio.h>
#include <stdlib.h>

// Structure for a BST node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new BST node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL)
        return createNode(data);
    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);
    return root;
}

// Function to perform level-wise traversal of the BST
void levelOrderTraversal(struct Node* root) {
    if (root == NULL)
        return;

    struct Node* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (front < rear) {
        struct Node* current = queue[front++];
        printf("%d ", current->data);

        if (current->left != NULL)
            queue[rear++] = current->left;
        if (current->right != NULL)
            queue[rear++] = current->right;
    }
}

// Function to find the node with minimum value in a BST
struct Node* minValueNode(struct Node* node) {
    struct Node* current = node;
    while (current->left != NULL)
        current = current->left;
    return current;
}

// Function to delete a node from the BST
struct Node* deleteNode(struct Node* root, int key) {
    if (root == NULL)
        return root;
    if (key < root->data)
        root->left = deleteNode(root->left, key);
    else if (key > root->data)
        root->right = deleteNode(root->right, key);
    else {
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }
        struct Node* temp = minValueNode(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Create Binary Search Tree\n");
    printf("2. Display BST Level-wise\n");
    printf("3. Delete a element\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct Node* root = NULL;
    int choice, numNodes, data, key;

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the number of elements: ");
                scanf("%d", &numNodes);
                printf("Enter the elements level-wise:\n");
                for (int i = 0; i < numNodes; i++) {
                    scanf("%d", &data);
                    root = insert(root, data);
                }
                break;
            case 2:
                printf("Level-wise traversal of the BST: ");
                levelOrderTraversal(root);
                printf("\n");
                break;
            case 3:
                printf("Enter the key to delete from the Binary Search Tree: ");
                scanf("%d", &key);
                root = deleteNode(root, key);
                printf("Element with key %d deleted successfully.\n", key);
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}
 
 
 

Write a Program to create a Binary Search Tree and display its mirror image with and without disturbing the original tree. Also display height of a tree using nonrecursion.
#include <stdio.h>
#include <stdlib.h>

// Structure for a BST node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Structure for queue node (used for level order traversal)
struct QueueNode {
    struct Node* treeNode;
    struct QueueNode* next;
};

// Function to create a new BST node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert an element into the BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL)
        return createNode(data);
    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);
    return root;
}

// Function to perform inorder traversal of the BST
void inorderTraversal(struct Node* root) {
    if (root == NULL)
        return;
    inorderTraversal(root->left);
    printf("%d ", root->data);
    inorderTraversal(root->right);
}

// Function to create the mirror image of the BST without disturbing the original tree
struct Node* mirrorImage(struct Node* root) {
    if (root == NULL)
        return NULL;

    struct Node* mirror = createNode(root->data);
    mirror->left = mirrorImage(root->right);
    mirror->right = mirrorImage(root->left);
    return mirror;
}

// Function to create the mirror image of the BST and update the original tree
void mirrorAndUpdate(struct Node* root) {
    if (root == NULL)
        return;

    struct Node* temp = root->left;
    root->left = root->right;
    root->right = temp;

    mirrorAndUpdate(root->left);
    mirrorAndUpdate(root->right);
}
// Function to enqueue a tree node into the queue
void enqueue(struct QueueNode** front, struct Node* treeNode) {
    struct QueueNode* newNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
    newNode->treeNode = treeNode;
    newNode->next = NULL;
    if (*front == NULL) {
        *front = newNode;
    } else {
        struct QueueNode* rear = *front;
        while (rear->next != NULL) {
            rear = rear->next;
        }
        rear->next = newNode;
    }
}

// Function to dequeue a tree node from the queue
struct Node* dequeue(struct QueueNode** front) {
    if (*front == NULL)
        return NULL;
    struct Node* dequeuedNode = (*front)->treeNode;
    struct QueueNode* temp = *front;
    *front = (*front)->next;
    free(temp);
    return dequeuedNode;
}

// Function to calculate the size of the queue
int queueSize(struct QueueNode* front) {
    int size = 0;
    while (front) {
        size++;
        front = front->next;
    }
    return size;
}
// Function to calculate the height of the tree using level order traversal
int heightNonRecursive(struct Node* root) {
    if (root == NULL)
        return 0;

    struct QueueNode* queue = NULL;
    enqueue(&queue, root);
    int height = 0;

    while (queue) {
        int levelSize = queueSize(queue);
        while (levelSize--) {
            struct Node* currNode = dequeue(&queue);
            if (currNode->left)
                enqueue(&queue, currNode->left);
            if (currNode->right)
                enqueue(&queue, currNode->right);
        }
        height++;
    }

    return height;
}
// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Create Binary Search Tree\n");
    printf("2. Display BST\n");
    printf("3. Display Mirror Image without Disturbing Original Tree\n");
    printf("4. Display Mirror Image with Updating Original Tree\n");
    printf("5. Calculate Height of the Tree (Non-Recursive)\n");
    printf("6. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct Node* root = NULL;
    int choice, numElements, data;

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the number of elements: ");
                scanf("%d", &numElements);
                printf("Enter the elements:\n");
                for (int i = 0; i < numElements; i++) {
                    scanf("%d", &data);
                    root = insert(root, data);
                }
                break;
            case 2:
                printf("BST: ");
                inorderTraversal(root);
                printf("\n");
                break;
            case 3:
                printf("Mirror Image without Disturbing Original Tree: ");
                inorderTraversal(mirrorImage(root));
                printf("\n");
                break;
            case 4:
                printf("Mirror Image with Updating Original Tree\n");
                mirrorAndUpdate(root);
                printf("BST: ");
                inorderTraversal(root);
                printf("\n");
                break;
            case 5:
                printf("Height of the Tree (Non-Recursive): %d\n", heightNonRecursive(root));
                break;
            case 6:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}

 
 
 
       WAP to implement following by using stack.
 A. Factorial of a given number B. Generation of Fibonacci series
A.Factorial
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

struct Stack {
    int top;
    int capacity;
    int* array;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (int*)malloc(stack->capacity * sizeof(int));
    return stack;
}

int isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

int isFull(struct Stack* stack) {
    return stack->top == stack->capacity - 1;
}

void push(struct Stack* stack, int data) {
    if (isFull(stack)) {
        printf("Stack overflow\n");
        return;
    }
    stack->array[++stack->top] = data;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack underflow\n");
        return -1;
    }
    return stack->array[stack->top--];
}

int factorial(int n) {
    struct Stack* stack = createStack(MAX_SIZE);
    int fact = 1;
    for (int i = 1; i <= n; i++) {
        push(stack, i);
    }
    while (!isEmpty(stack)) {
        fact *= pop(stack);
    }
    return fact;
}

int main() {
    int n;
    printf("Enter a number: ");
    scanf("%d", &n);
    printf("Factorial of %d is %d\n", n, factorial(n));
    return 0;
}


B.Fibonacci
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

struct Stack {
    int top;
    int capacity;
    int* array;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (int*)malloc(stack->capacity * sizeof(int));
    return stack;
}

int isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

int isFull(struct Stack* stack) {
    return stack->top == stack->capacity - 1;
}

void push(struct Stack* stack, int data) {
    if (isFull(stack)) {
        printf("Stack overflow\n");
        return;
    }
    stack->array[++stack->top] = data;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack underflow\n");
        return -1;
    }
    return stack->array[stack->top--];
}

void generateFibonacci(int n) {
    struct Stack* stack = createStack(MAX_SIZE);
    int a = 0, b = 1, c;
    printf("Fibonacci series up to %d terms: ", n);
    for (int i = 1; i <= n; i++) {
        printf("%d ", a);
        push(stack, a);
        c = a + b;
        a = b;
        b = c;
    }
    printf("\n");
    printf("Fibonacci series retrieved from stack: ");
    while (!isEmpty(stack)) {
        printf("%d ", pop(stack));
    }
    printf("\n");
}

int main() {
    int n;
    printf("Enter the number of terms for Fibonacci series: ");
    scanf("%d", &n);
    generateFibonacci(n);
    return 0;
}



 	Write a Program to implement circular double ended queue where user can add and remove the elements from both front and rear of the queue
#include <stdio.h>
#include <stdlib.h>

#define MAX 5

typedef struct {
    int arr[MAX];
    int front;
    int rear;
} Deque;

void initialize(Deque *dq) {
    dq->front = -1;
    dq->rear = -1;
}

int isFull(Deque *dq) {
    return ((dq->front == 0 && dq->rear == MAX - 1) || dq->front == dq->rear + 1);
}

int isEmpty(Deque *dq) {
    return (dq->front == -1);
}

void insertFront(Deque *dq, int item) {
    if (isFull(dq)) {
        printf("Queue Overflow\n");
        return;
    }

    if (dq->front == -1) {
        dq->front = 0;
        dq->rear = 0;
    } else if (dq->front == 0) {
        dq->front = MAX - 1;
    } else {
        dq->front = dq->front - 1;
    }

    dq->arr[dq->front] = item;
}

void insertRear(Deque *dq, int item) {
    if (isFull(dq)) {
        printf("Queue Overflow\n");
        return;
    }

    if (dq->front == -1) {
        dq->front = 0;
        dq->rear = 0;
    } else if (dq->rear == MAX - 1) {
        dq->rear = 0;
    } else {
        dq->rear = dq->rear + 1;
    }

    dq->arr[dq->rear] = item;
}

void deleteFront(Deque *dq) {
    if (isEmpty(dq)) {
        printf("Queue Underflow\n");
        return;
    }

    printf("Element deleted from front is %d\n", dq->arr[dq->front]);

    if (dq->front == dq->rear) {
        dq->front = -1;
        dq->rear = -1;
    } else if (dq->front == MAX - 1) {
        dq->front = 0;
    } else {
        dq->front = dq->front + 1;
    }
}

void deleteRear(Deque *dq) {
    if (isEmpty(dq)) {
        printf("Queue Underflow\n");
        return;
    }

    printf("Element deleted from rear is %d\n", dq->arr[dq->rear]);

    if (dq->front == dq->rear) {
        dq->front = -1;
        dq->rear = -1;
    } else if (dq->rear == 0) {
        dq->rear = MAX - 1;
    } else {
        dq->rear = dq->rear - 1;
    }
}

void display(Deque *dq) {
    int i;

    if (isEmpty(dq)) {
        printf("Queue is empty\n");
        return;
    }

    printf("Queue elements are:\n");

    if (dq->front <= dq->rear) {
        for (i = dq->front; i <= dq->rear; i++)
            printf("%d ", dq->arr[i]);
    } else {
        for (i = dq->front; i < MAX; i++)
            printf("%d ", dq->arr[i]);
        for (i = 0; i <= dq->rear; i++)
            printf("%d ", dq->arr[i]);
    }

    printf("\n");
}

int main() {
    Deque dq;
    initialize(&dq);
    int choice, item;

    while (1) {
        printf("\n1. Insert at front\n");
        printf("2. Insert at rear\n");
        printf("3. Delete from front\n");
        printf("4. Delete from rear\n");
        printf("5. Display\n");
        printf("6. Quit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Input the element for insertion in front: ");
                scanf("%d", &item);
                insertFront(&dq, item);
                break;
            case 2:
                printf("Input the element for insertion in rear: ");
                scanf("%d", &item);
                insertRear(&dq, item);
                break;
            case 3:
                deleteFront(&dq);
                break;
            case 4:
                deleteRear(&dq);
                break;
            case 5:
                display(&dq);
                break;
            case 6:
                exit(0);
            default:
                printf("Wrong choice\n");
        }
    }

    return 0;
}


________________________________________

 	Write a Program to implement multiple two queues using array and perform following operations on it. A. Addq, B. Delq, C. Display Queue.
#include <stdio.h>
#include <stdlib.h>

#define MAX 10

typedef struct {
    int arr[MAX];
    int front1, rear1;
    int front2, rear2;
} TwoQueues;

void initialize(TwoQueues *queues) {
    queues->front1 = -1;
    queues->rear1 = -1;
    queues->front2 = MAX;
    queues->rear2 = MAX;
}

int isFull1(TwoQueues *queues) {
    return (queues->rear1 + 1 == queues->front2);
}

int isFull2(TwoQueues *queues) {
    return (queues->rear2 - 1 == queues->rear1);
}

int isEmpty1(TwoQueues *queues) {
    return (queues->front1 == -1);
}

int isEmpty2(TwoQueues *queues) {
    return (queues->front2 == MAX);
}

void Addq1(TwoQueues *queues, int item) {
    if (isFull1(queues)) {
        printf("Queue 1 Overflow\n");
        return;
    }

    if (queues->front1 == -1) {
        queues->front1 = 0;
    }
    queues->rear1++;
    queues->arr[queues->rear1] = item;
}

void Addq2(TwoQueues *queues, int item) {
    if (isFull2(queues)) {
        printf("Queue 2 Overflow\n");
        return;
    }

    if (queues->front2 == MAX) {
        queues->front2 = MAX - 1;
    }
    queues->rear2--;
    queues->arr[queues->rear2] = item;
}

void Delq1(TwoQueues *queues) {
    if (isEmpty1(queues)) {
        printf("Queue 1 Underflow\n");
        return;
    }

    printf("Element deleted from Queue 1 is %d\n", queues->arr[queues->front1]);
    if (queues->front1 == queues->rear1) {
        queues->front1 = -1;
        queues->rear1 = -1;
    } else {
        queues->front1++;
    }
}

void Delq2(TwoQueues *queues) {
    if (isEmpty2(queues)) {
        printf("Queue 2 Underflow\n");
        return;
    }

    printf("Element deleted from Queue 2 is %d\n", queues->arr[queues->front2]);
    if (queues->front2 == queues->rear2) {
        queues->front2 = MAX;
        queues->rear2 = MAX;
    } else {
        queues->front2--;
    }
}

void displayQueue1(TwoQueues *queues) {
    if (isEmpty1(queues)) {
        printf("Queue 1 is empty\n");
        return;
    }

    printf("Queue 1 elements are:\n");
    for (int i = queues->front1; i <= queues->rear1; i++) {
        printf("%d ", queues->arr[i]);
    }
    printf("\n");
}

void displayQueue2(TwoQueues *queues) {
    if (isEmpty2(queues)) {
        printf("Queue 2 is empty\n");
        return;
    }

    printf("Queue 2 elements are:\n");
    for (int i = queues->front2; i >= queues->rear2; i--) {
        printf("%d ", queues->arr[i]);
    }
    printf("\n");
}

int main() {
    TwoQueues queues;
    initialize(&queues);
    int choice, item, queueNumber;

    while (1) {
        printf("\n1. Addq\n");
        printf("2. Delq\n");
        printf("3. Display Queue\n");
        printf("4. Quit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter queue number (1 or 2): ");
                scanf("%d", &queueNumber);
                printf("Input the element to add: ");
                scanf("%d", &item);
                if (queueNumber == 1) {
                    Addq1(&queues, item);
                } else if (queueNumber == 2) {
                    Addq2(&queues, item);
                } else {
                    printf("Invalid queue number\n");
                }
                break;
            case 2:
                printf("Enter queue number (1 or 2): ");
                scanf("%d", &queueNumber);
                if (queueNumber == 1) {
                    Delq1(&queues);
                } else if (queueNumber == 2) {
                    Delq2(&queues);
                } else {
                    printf("Invalid queue number\n");
                }
                break;
            case 3:
                printf("Enter queue number (1 or 2): ");
                scanf("%d", &queueNumber);
                if (queueNumber == 1) {
                    displayQueue1(&queues);
                } else if (queueNumber == 2) {
                    displayQueue2(&queues);
                } else {
                    printf("Invalid queue number\n");
                }
                break;
            case 4:
                exit(0);
            default:
                printf("Wrong choice\n");
        }
    }

    return 0;
}
       WAP to perform addition of two polynomials using singly linked list.
________________________________________
 	Write an iterative Reverse() function that reverses a list by rearranging all the next pointers and the head pointer. Ideally, Reverse() should only need to make one pass of the list.
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

void Reverse(struct Node** headRef) {
    struct Node* prev = NULL;
    struct Node* current = *headRef;
    struct Node* next = NULL;
    
    while (current != NULL) {
        next = current->next;  // Store next node
        current->next = prev;  // Reverse current node's pointer
        prev = current;        // Move pointers one position ahead
        current = next;
    }
    *headRef = prev;  // Update head to new front
}

void push(struct Node** headRef, int newData) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = newData;
    newNode->next = *headRef;
    *headRef = newNode;
}

void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* head = NULL;

    push(&head, 5);
    push(&head, 4);
    push(&head, 3);
    push(&head, 2);
    push(&head, 1);

    printf("Original List: \n");
    printList(head);

    Reverse(&head);

    printf("Reversed List: \n");
    printList(head);

    return 0;
}
       WAP to create doubly linked list and perform following operations on it. A) Insert (all cases) 2. Delete (all cases).
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

void insertAtBeginning(struct Node** headRef, int data) {
    struct Node* newNode = createNode(data);
    newNode->next = *headRef;
    if (*headRef != NULL) {
        (*headRef)->prev = newNode;
    }
    *headRef = newNode;
}

void insertAtEnd(struct Node** headRef, int data) {
    struct Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    struct Node* temp = *headRef;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
    newNode->prev = temp;
}

void insertAfter(struct Node* prevNode, int data) {
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL\n");
        return;
    }
    struct Node* newNode = createNode(data);
    newNode->next = prevNode->next;
    prevNode->next = newNode;
    newNode->prev = prevNode;
    if (newNode->next != NULL) {
        newNode->next->prev = newNode;
    }
}

void deleteFromBeginning(struct Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    struct Node* temp = *headRef;
    *headRef = (*headRef)->next;
    if (*headRef != NULL) {
        (*headRef)->prev = NULL;
    }
    free(temp);
}

void deleteFromEnd(struct Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    struct Node* temp = *headRef;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    if (temp->prev != NULL) {
        temp->prev->next = NULL;
    } else {
        *headRef = NULL;
    }
    free(temp);
}

void deleteNode(struct Node** headRef, struct Node* delNode) {
    if (*headRef == NULL || delNode == NULL) {
        printf("The given node cannot be deleted\n");
        return;
    }
    if (*headRef == delNode) {
        *headRef = delNode->next;
    }
    if (delNode->next != NULL) {
        delNode->next->prev = delNode->prev;
    }
    if (delNode->prev != NULL) {
        delNode->prev->next = delNode->next;
    }
    free(delNode);
}

void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* head = NULL;

    insertAtBeginning(&head, 1);
    insertAtBeginning(&head, 2);
    insertAtBeginning(&head, 3);
    printf("List after inserting at beginning: ");
    printList(head);

 
    insertAtEnd(&head, 4);
    insertAtEnd(&head, 5);
    printf("List after inserting at end: ");
    printList(head);

    insertAfter(head->next, 6);
    printf("List after inserting after the second node: ");
    printList(head);

    deleteFromBeginning(&head);
    printf("List after deleting from beginning: ");
    printList(head);

    deleteFromEnd(&head);
    printf("List after deleting from end: ");
    printList(head);

    deleteNode(&head, head->next);
    printf("List after deleting the second node: ");
    printList(head);

    return 0;
}


       WAP to merge two sorted Doubly linked lists and display their result.
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

void insertAtEnd(struct Node** headRef, int data) {
    struct Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    struct Node* temp = *headRef;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
    newNode->prev = temp;
}

struct Node* mergeSortedLists(struct Node* head1, struct Node* head2) {
    if (head1 == NULL) return head2;
    if (head2 == NULL) return head1;

    struct Node* mergedHead = NULL;

    if (head1->data <= head2->data) {
        mergedHead = head1;
        head1 = head1->next;
    } else {
        mergedHead = head2;
        head2 = head2->next;
    }

    struct Node* mergedTail = mergedHead;

    while (head1 != NULL && head2 != NULL) {
        if (head1->data <= head2->data) {
            mergedTail->next = head1;
            head1->prev = mergedTail;
            head1 = head1->next;
        } else {
            mergedTail->next = head2;
            head2->prev = mergedTail;
            head2 = head2->next;
        }
        mergedTail = mergedTail->next;
    }

    if (head1 != NULL) {
        mergedTail->next = head1;
        head1->prev = mergedTail;
    } else if (head2 != NULL) {
        mergedTail->next = head2;
        head2->prev = mergedTail;
    }

    return mergedHead;
}

void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* head1 = NULL;
    struct Node* head2 = NULL;

    
    insertAtEnd(&head1, 1);
    insertAtEnd(&head1, 3);
    insertAtEnd(&head1, 5);

    insertAtEnd(&head2, 2);
    insertAtEnd(&head2, 4);
    insertAtEnd(&head2, 6);

    printf("First Sorted List: ");
    printList(head1);

    printf("Second Sorted List: ");
    printList(head2);

    struct Node* mergedHead = mergeSortedLists(head1, head2);

    printf("Merged Sorted List: ");
    printList(mergedHead);

    return 0;
}


       Implement Push and POP operations of STACK on Doubly linked lists
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

void push(struct Node** topRef, int data) {
    struct Node* newNode = createNode(data);
    if (*topRef != NULL) {
        newNode->next = *topRef;
        (*topRef)->prev = newNode;
    }
    *topRef = newNode;
    printf("Pushed %d onto the stack\n", data);
}

int pop(struct Node** topRef) {
    if (*topRef == NULL) {
        printf("Stack underflow\n");
        return -1;
    }
    struct Node* temp = *topRef;
    int poppedData = temp->data;
    *topRef = temp->next;
    if (*topRef != NULL) {
        (*topRef)->prev = NULL;
    }
    free(temp);
    printf("Popped %d from the stack\n", poppedData);
    return poppedData;
}

void printStack(struct Node* top) {
    struct Node* temp = top;
    printf("Stack: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* top = NULL;

    push(&top, 10);
    push(&top, 20);
    push(&top, 30);

    printStack(top);

    pop(&top);
    pop(&top);

    printStack(top);

    pop(&top);

    pop(&top);

    return 0;
}


       Implement ADD and DELETE operations of QUEUE on Doubly linked lists
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

void add(struct Node** frontRef, struct Node** rearRef, int data) {
    struct Node* newNode = createNode(data);
    if (*rearRef == NULL) {
        *frontRef = *rearRef = newNode;
    } else {
        (*rearRef)->next = newNode;
        newNode->prev = *rearRef;
        *rearRef = newNode;
    }
    printf("Added %d to the queue\n", data);
}

int delete(struct Node** frontRef, struct Node** rearRef) {
    if (*frontRef == NULL) {
        printf("Queue underflow\n");
        return -1;
    }
    struct Node* temp = *frontRef;
    int deletedData = temp->data;
    *frontRef = (*frontRef)->next;
    if (*frontRef != NULL) {
        (*frontRef)->prev = NULL;
    } else {
        *rearRef = NULL;
    }
    free(temp);
    printf("Deleted %d from the queue\n", deletedData);
    return deletedData;
}

void printQueue(struct Node* front) {
    struct Node* temp = front;
    printf("Queue: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* front = NULL;
    struct Node* rear = NULL;

    add(&front, &rear, 10);
    add(&front, &rear, 20);
    add(&front, &rear, 30);

    printQueue(front);

    delete(&front, &rear);
    delete(&front, &rear);

    printQueue(front);

    delete(&front, &rear);
    
    delete(&front, &rear);

    return 0;
}






 Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Preorder Traversal b. Count Leaf Nodes c. Count total no. of nodes d. Display height of a tree.
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Definition of the stack used for non-recursive traversals
struct stackNode {
    struct node *treeNode;
    struct stackNode *next;
};

// Stack operations
struct stackNode *stackTop = NULL;

// Function to push a node onto the stack
void push(struct node *t) {
    struct stackNode *newNode = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->treeNode = t;
    newNode->next = stackTop;
    stackTop = newNode;
}

// Function to pop a node from the stack
struct node *pop() {
    if (stackTop == NULL) {
        printf("Stack is empty\n");
        return NULL;
    } else {
        struct node *temp = stackTop->treeNode;
        struct stackNode *t = stackTop;
        stackTop = stackTop->next;
        free(t);
        return temp;
    }
}

// Function to create a new binary tree node
struct node *createNode(int key) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    newNode->data = key;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function for non-recursive Preorder Traversal
void preorderTraversal(struct node *root) {
    struct node *current = root;
    while (current != NULL || stackTop != NULL) {
        while (current != NULL) {
            printf("%d ", current->data);
            push(current);
            current = current->left;
        }
        current = pop();
        current = current->right;
    }
    printf("\n");
}

// Function to insert a node into the binary tree
struct node *insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else {
        root->right = insert(root->right, data);
    }
    return root;
}

// Function to count the total number of nodes in the binary tree
int countTotalNodes(struct node *root) {
    if (root == NULL) return 0;

    struct node *current;
    struct stackNode *tempStack = NULL;
    int count = 0;

    push(root);
    while (stackTop != NULL) {
        current = pop();
        count++;
        if (current->right) push(current->right);
        if (current->left) push(current->left);
    }
    return count;
}

// Function to count the number of leaf nodes in the binary tree
int countLeafNodes(struct node *root) {
    if (root == NULL) return 0;

    struct node *current;
    int leafCount = 0;
    push(root);

    while (stackTop != NULL) {
        current = pop();
        if (current->left == NULL && current->right == NULL) {
            leafCount++;
        }
        if (current->right) push(current->right);
        if (current->left) push(current->left);
    }
    return leafCount;
}

// Function to find the height of the binary tree
int findHeight(struct node *root) {
    if (root == NULL) return 0;

    struct node *current;
    struct stackNode *tempStack = NULL;
    int maxHeight = 0, currentHeight = 0;

    push(root);
    while (stackTop != NULL) {
        current = pop();
        if (current->left == NULL && current->right == NULL) {
            if (currentHeight > maxHeight) {
                maxHeight = currentHeight;
            }
        }
        if (current->right) {
            push(current->right);
            currentHeight++;
        }
        if (current->left) {
            push(current->left);
            currentHeight++;
        }
    }
    return maxHeight;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 12);
    root = insert(root, 7);
    root = insert(root, 5);
    root = insert(root, 8);
    root = insert(root, 11);
    root = insert(root, 14);

    printf("Non-recursive Preorder Traversal: ");
    preorderTraversal(root);

    int totalNodes = countTotalNodes(root);
    printf("Total number of nodes: %d\n", totalNodes);

    int leafNodes = countLeafNodes(root);
    printf("Number of leaf nodes: %d\n", leafNodes);

    int height = findHeight(root);
    printf("Height of the tree: %d\n", height);

    return 0;
}



Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Inorder Traversal b. Mirror Image c. Count total no. of nodes d. Display height of a tree.

#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

struct node* createNode(int data);
void inorderNonRecursive(struct node *root);
void mirrorImage(struct node *root);
int countNodes(struct node *root);
int height(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);
int queueSize(struct queueNode *front);
struct node* insert(struct node *root, int data);

// Create a new node for the binary tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Perform inorder traversal of the binary tree (non-recursive)
void inorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *top = NULL;
    struct node *current = root;

    while (current != NULL || top != NULL) {
        while (current != NULL) {
            push(&top, current);
            current = current->left;
        }
        current = pop(&top);
        printf("%d ", current->data);
        current = current->right;
    }
    printf("\n");
}

// Generate the mirror image of the binary tree
void mirrorImage(struct node *root) {
    if (root == NULL) {
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        struct node *temp = current->left;
        current->left = current->right;
        current->right = temp;

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
}

// Count total number of nodes in the binary tree
int countNodes(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    struct queueNode *front = NULL, *rear = NULL;
    int count = 0;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        count++;

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    return count;
}

// Calculate the height of the binary tree
int height(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    struct queueNode *front = NULL, *rear = NULL;
    int height = 0;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        int size = queueSize(front);
        while (size > 0) {
            struct node *current = dequeue(&front, &rear);
            if (current->left != NULL) {
                enqueue(&front, &rear, current->left);
            }
            if (current->right != NULL) {
                enqueue(&front, &rear, current->right);
            }
            size--;
        }
        height++;
    }
    return height;
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

// Get the size of the queue
int queueSize(struct queueNode *front) {
    int size = 0;
    while (front != NULL) {
        size++;
        front = front->next;
    }
    return size;
}

// Insert a node into the binary tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        root = createNode(data);
    } else {
        if (data <= root->data) {
            root->left = insert(root->left, data);
        } else {
            root->right = insert(root->right, data);
        }
    }
    return root;
}

int main() {
    struct node *root = NULL;

    // Inserting nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 12);
    root = insert(root, 7);
    root = insert(root, 5);
    root = insert(root, 8);
    root = insert(root, 11);
    root = insert(root, 14);
    printf("Inorder Traversal: ");
    inorderNonRecursive(root);

    mirrorImage(root);
    printf("Mirror Image: ");
    inorderNonRecursive(root);

    printf("Total Number of Nodes: %d\n", countNodes(root));
    printf("Height of the Tree: %d\n", height(root));

    return 0;
    }

Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Postorder Traversal b. Display Leaf Nodes c. Count total no. of  Leaf nodes d. Display height of a tree.
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Function prototypes
void postorderTraversal(struct node *root);
void displayLeafNodes(struct node *root);
int countLeafNodes(struct node *root);
int height(struct node *root);
struct node *insert(struct node *root, int data);

// Insert a node into the binary tree
struct node *insert(struct node *root, int data) {
    if (root == NULL) {
        root = (struct node *)malloc(sizeof(struct node));
        if (root == NULL) {
            printf("Memory allocation failed\n");
            exit(1);
        }
        root->data = data;
        root->left = NULL;
        root->right = NULL;
    } else {
        if (data <= root->data) {
            root->left = insert(root->left, data);
        } else {
            root->right = insert(root->right, data);
        }
    }
    return root;
}

// Perform postorder traversal of the binary tree
void postorderTraversal(struct node *root) {
    if (root == NULL) {
        return;
    }
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    printf("%d ", root->data);
}

// Display leaf nodes of the binary tree
void displayLeafNodes(struct node *root) {
    if (root == NULL) {
        return;
    }
    if (root->left == NULL && root->right == NULL) {
        printf("%d ", root->data);
    }
    displayLeafNodes(root->left);
    displayLeafNodes(root->right);
}

// Count total number of leaf nodes in the binary tree
int countLeafNodes(struct node *root) {
    if (root == NULL) {
        return 0;
    }
    if (root->left == NULL && root->right == NULL) {
        return 1;
    }
    return countLeafNodes(root->left) + countLeafNodes(root->right);
}

// Calculate the height of the binary tree
int height(struct node *root) {
    if (root == NULL) {
        return 0;
    }
    int leftHeight = height(root->left);
    int rightHeight = height(root->right);
    return (leftHeight > rightHeight) ? (leftHeight + 1) : (rightHeight + 1);
}

int main() {
    struct node *root = NULL;

    // Inserting nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 12);
    root = insert(root, 7);
    root = insert(root, 5);
    root = insert(root, 8);
    root = insert(root, 11);
    root = insert(root, 14);

    printf("Postorder Traversal: ");
    postorderTraversal(root);
    printf("\n");

    printf("Leaf Nodes: ");
    displayLeafNodes(root);
    printf("\n");

    printf("Total Number of Leaf Nodes: %d\n", countLeafNodes(root));

    printf("Height of the Tree: %d\n", height(root));

    return 0;
}



Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Level-wise Traversal b. Display Leaf Nodes c. Count total no. of Leaf nodes d. Display height of a tree.
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
void levelOrderTraversal(struct node *root);
void displayLeafNodes(struct node *root);
int countLeafNodes(struct node *root);
int height(struct node *root);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);
int queueSize(struct queueNode *front);

// Create a new node for the binary tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Perform level-wise traversal of the binary tree (non-recursive)
void levelOrderTraversal(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        printf("%d ", current->data);

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Display leaf nodes of the binary tree
void displayLeafNodes(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    printf("Leaf Nodes: ");
    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        if (current->left == NULL && current->right == NULL) {
            printf("%d ", current->data);
        }
        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Count total number of leaf nodes in the binary tree
int countLeafNodes(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    struct queueNode *front = NULL, *rear = NULL;
    int count = 0;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        if (current->left == NULL && current->right == NULL) {
            count++;
        }
        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    return count;
}

// Calculate the height of the binary tree
int height(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    struct queueNode *front = NULL, *rear = NULL;
    int height = 0;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        int size = queueSize(front);
        while (size > 0) {
            struct node *current = dequeue(&front, &rear);
            if (current->left != NULL) {
                enqueue(&front, &rear, current->left);
            }
            if (current->right != NULL) {
                enqueue(&front, &rear, current->right);
            }
            size--;
        }
        height++;
    }
    return height;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL)
        {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

// Get the size of the queue
int queueSize(struct queueNode *front) {
    int size = 0;
    while (front != NULL) {
        size++;
        front = front->next;
    }
    return size;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 12);
    root = insert(root, 7);
    root = insert(root, 5);
    root = insert(root, 8);
    root = insert(root, 11);
    root = insert(root, 14);

    printf("Level-wise Traversal: ");
    levelOrderTraversal(root);

    displayLeafNodes(root);

    printf("Total Number of Leaf Nodes: %d\n", countLeafNodes(root));
    printf("Height of the Tree: %d\n", height(root));

    return 0;
}




________________________________________
 	Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Levelwise display b. Mirror image c. Display height of a tree.
#include <stdio.h>
 	#include <stdlib.h>
 	
 	// Definition of the binary tree node
 	struct node {
 	    int data;
 	    struct node *left, *right;
 	};
 	
 	// Queue node structure for level-wise traversal
 	struct queueNode {
 	    struct node *TreeNode;
 	    struct queueNode *next;
 	};
 	
 	// Function prototypes
 	struct node* createNode(int data);
 	struct node* insert(struct node *root, int data);
 	void levelOrderTraversal(struct node *root);
 	void mirrorImage(struct node *root);
 	int height(struct node *root);
 	void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
 	struct node* dequeue(struct queueNode **front, struct queueNode **rear);
 	int queueSize(struct queueNode *front);
 	
 	// Create a new node for the binary tree
 	struct node* createNode(int data) {
 	    struct node *newNode = (struct node *)malloc(sizeof(struct node));
 	    if (newNode == NULL) {
 	        printf("Memory allocation failed\n");
 	        exit(1);
 	    }
 	    newNode->data = data;
 	    newNode->left = NULL;
 	    newNode->right = NULL;
 	    return newNode;
 	}
 	
 	// Insert a node into the binary tree
 	struct node* insert(struct node *root, int data) {
 	    if (root == NULL) {
 	        return createNode(data);
 	    }
 	    if (data < root->data) {
 	        root->left = insert(root->left, data);
 	    } else if (data > root->data) {
 	        root->right = insert(root->right, data);
 	    }
 	    return root;
 	}
 	
 	// Perform level-wise traversal of the binary tree (non-recursive)
 	void levelOrderTraversal(struct node *root) {
 	    if (root == NULL) {
 	        printf("Tree is empty.\n");
 	        return;
 	    }
 	
 	    struct queueNode *front = NULL, *rear = NULL;
 	    enqueue(&front, &rear, root);
 	
 	    while (front != NULL) {
 	        struct node *current = dequeue(&front, &rear);
 	        printf("%d ", current->data);
 	
 	        if (current->left != NULL) {
 	            enqueue(&front, &rear, current->left);
 	        }
 	        if (current->right != NULL) {
 	            enqueue(&front, &rear, current->right);
 	        }
 	    }
 	    printf("\n");
 	}
 	
 	// Generate the mirror image of the binary tree
 	void mirrorImage(struct node *root) {
 	    if (root == NULL) {
 	        return;
 	    }
 	
 	    struct queueNode *front = NULL, *rear = NULL;
 	    enqueue(&front, &rear, root);
 	
 	    while (front != NULL) {
 	        struct node *current = dequeue(&front, &rear);
 	        struct node *temp = current->left;
 	        current->left = current->right;
 	        current->right = temp;
 	
 	        if (current->left != NULL) {
 	            enqueue(&front, &rear, current->left);
 	        }
 	        if (current->right != NULL) {
 	            enqueue(&front, &rear, current->right);
 	        }
 	    }
 	}
 	
 	// Calculate the height of the binary tree
 	int height(struct node *root) {
 	    if (root == NULL) {
 	        return 0;
 	    }
 	
 	    struct queueNode *front = NULL, *rear = NULL;
 	    int height = 0;
 	    enqueue(&front, &rear, root);
 	
 	    while (front != NULL) {
 	        int size = queueSize(front);
 	        while (size > 0) {
 	            struct node *current = dequeue(&front, &rear);
 	            if (current->left != NULL) {
 	                enqueue(&front, &rear, current->left);
 	            }
 	            if (current->right != NULL) {
 	                enqueue(&front, &rear, current->right);
 	            }
 	            size--;
 	        }
 	        height++;
 	    }
 	    return height;
 	}
 	
 	// Enqueue a node into the queue for level-wise traversal
 	void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
 	    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
 	    if (temp == NULL) {
 	        printf("Memory allocation failed\n");
 	        exit(1);
 	    }
 	    temp->TreeNode = TreeNode;
 	    temp->next = NULL;
 	    if (*rear == NULL) {
 	        *front = *rear = temp;
 	    } else {
 	        (*rear)->next = temp;
 	        *rear = temp;
 	    }
 	}
 	
 	// Dequeue a node from the queue for level-wise traversal
 	struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
 	    if (*front == NULL) {
 	        printf("Queue is empty\n");
 	        exit(1);
 	    }
 	    struct queueNode *temp = *front;
 	    struct node *TreeNode = temp->TreeNode;
 	    *front = (*front)->next;
 	    if (*front == NULL) {
 	        *rear = NULL;
 	    }
 	    free(temp);
 	    return TreeNode;
 	}
 	
 	// Get the size of the queue
 	int queueSize(struct queueNode *front) {
 	    int size = 0;
 	    while (front != NULL) {
 	        size++;
 	        front = front->next;
 	    }
 	    return size;
 	}
 	
 	int main() {
 	    struct node *root = NULL;
 	
 	    // Insert nodes into the binary tree
 	    root = insert(root, 10);
 	    root = insert(root, 12);
 	    root = insert(root, 7);
 	    root = insert(root, 5);
 	    root = insert(root, 8);
 	    root = insert(root, 11);
 	    root = insert(root, 14);
 	
 	    printf("Level-wise Traversal: ");
 	    levelOrderTraversal(root);
 	
 	    mirrorImage(root);
 	    printf("Mirror Image: ");
 	    levelOrderTraversal(root);
 	
 	    printf("Height of the Tree: %d\n", height(root));
 	
 	    return 0;
 	}
 	

________________________________________
       Write a program to illustrate operations on a BST holding numeric keys. The menu must include: • Insert • Delete • Find 
• Level wise Display
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
struct node* deleteNode(struct node *root, int key);
struct node* minValueNode(struct node *node);
struct node* find(struct node *root, int key);
void levelOrderTraversal(struct node *root);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);
int queueSize(struct queueNode *front);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Delete a node from the binary search tree
struct node* deleteNode(struct node *root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }
        struct node *temp = minValueNode(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Find the node with the minimum value in a subtree
struct node* minValueNode(struct node *node) {
    struct node *current = node;
    while (current && current->left != NULL) {
        current = current->left;
    }
    return current;
}

// Find a node with the given key in the binary search tree
struct node* find(struct node *root, int key) {
    while (root != NULL) {
        if (key == root->data) {
            return root;
        } else if (key < root->data) {
            root = root->left;
        } else {
            root = root->right;
        }
    }
    return NULL;
}

// Perform level-wise traversal of the binary search tree (non-recursive)
void levelOrderTraversal(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        printf("%d ", current->data);

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

// Get the size of the queue
int queueSize(struct queueNode *front) {
    int size = 0;
    while (front != NULL) {
        size++;
        front = front->next;
    }
    return size;
}

int main() {
    struct node *root = NULL;

    while (1) {
        printf("\nBinary Search Tree Operations:\n");
        printf("1. Insert\n");
        printf("2. Delete\n");
        printf("3. Find\n");
        printf("4. Level-wise Display\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                int data;
                printf("Enter the data to insert: ");
                scanf("%d", &data);
                root = insert(root, data);
                printf("Data %d inserted into the tree.\n", data);
                break;
            }
            case 2: {
                int key;
                printf("Enter the key to delete: ");
                scanf("%d", &key);
                root = deleteNode(root, key);
                printf("Node with key %d deleted from the tree.\n", key);
                break;
            }
            case 3: {
                int key;
                printf("Enter the key to find: ");
                scanf("%d", &key);
                struct node *foundNode = find(root, key);
                if (foundNode != NULL) {
                    printf("Node with key %d found in the tree.\n", key);
                } else {
                    printf("Node with key %d not found in the tree.\n", key);
                }
                break;
            }
            case 4:
                printf("Level-wise Display: ");
                levelOrderTraversal(root);
                break;
            case 5:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice!\n");
        }
    }

    return 0;
}


________________________________________
       Write a program to illustrate operations on a BST holding numeric keys. The menu must include: • Insert • Mirror Image       • Find • Height of the tree
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
struct node* deleteNode(struct node *root, int key);
struct node* minValueNode(struct node *node);
struct node* find(struct node *root, int key);
void levelOrderTraversal(struct node *root);
void mirrorImage(struct node *root);
int height(struct node *root);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);
int queueSize(struct queueNode *front);
struct node* cloneTree(struct node *root);
void inorderTraversal(struct node *root);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Delete a node from the binary search tree
struct node* deleteNode(struct node *root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }
        struct node *temp = minValueNode(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Find the node with the minimum value in a subtree
struct node* minValueNode(struct node *node) {
    struct node *current = node;
    while (current && current->left != NULL) {
        current = current->left;
    }
    return current;
}

// Find a node with the given key in the binary search tree
struct node* find(struct node *root, int key) {
    while (root != NULL) {
        if (key == root->data) {
            return root;
        } else if (key < root->data) {
            root = root->left;
        } else {
            root = root->right;
        }
    }
    return NULL;
}

// Perform level-wise traversal of the binary search tree (non-recursive)
void levelOrderTraversal(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        printf("%d ", current->data);

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Generate the mirror image of the binary search tree
void mirrorImage(struct node *root) {
    if (root == NULL) {
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        struct node *temp = current->left;
        current->left = current->right;
        current->right = temp;

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
}

// Calculate the height of the binary search tree
int height(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    struct queueNode *front = NULL, *rear = NULL;
    int height = 0;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        int size = queueSize(front);
        while (size > 0) {
            struct node *current = dequeue(&front, &rear);
            if (current->left != NULL) {
                enqueue(&front, &rear, current->left);
            }
            if (current->right != NULL) {
                enqueue(&front, &rear, current->right);
            }
            size--;
        }
        height++;
    }
    return height;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

// Get the size of the queue
int queueSize(struct queueNode *front) {
    int size = 0;
    while (front != NULL) {
        size++;
        front = front->next;
    }
    return size;
}

// Clone a binary tree
struct node* cloneTree(struct node *root) {
    if (root == NULL) {
        return NULL;
    }
    struct node *newNode = createNode(root->data);
    newNode->left = cloneTree(root->left);
    newNode->right = cloneTree(root->right);
    return newNode;
}

// Perform in-order traversal to display the tree
void inorderTraversal(struct node *root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);
        inorderTraversal(root->right);
    }
}

int main() {
    struct node *root = NULL;

    while (1) {
        printf("\nBinary Search Tree Operations:\n");
        printf("1. Insert\n");
        printf("2. Mirror Image\n");
        printf("3. Find\n");
        printf("4. Height of the tree\n");
        printf("5. Level-wise Display\n");
        printf("6. Display Original Tree In-order\n");
        printf("7. Display Mirror Image In-order\n");
        printf("8. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                int data;
                printf("Enter the data to insert: ");
                scanf("%d", &data);
                root = insert(root, data);
                printf("Data %d inserted into the tree.\n", data);
                break;
            }
            case 2: {
                struct node *mirrorRoot = cloneTree(root);
                printf("Generating Mirror Image...\n");
                mirrorImage(mirrorRoot);
                printf("Mirror Image generated successfully.\n");

                // Display mirror image tree
                printf("Mirror Image In-order Traversal: ");
                inorderTraversal(mirrorRoot);
                printf("\n");
                break;
            }
            case 3: {
                int key;
                printf("Enter the key to find: ");
                scanf("%d", &key);
                struct node *foundNode = find(root, key);
                if (foundNode != NULL) {
                    printf("Node with key %d found in the tree.\n", key);
                } else {
                    printf("Node with key %d not found in the tree.\n", key);
                }
                break;
            }
            case 4:
                printf("Height of the Tree: %d\n", height(root));
                break;
            case 5:
                printf("Level-wise Display: ");
                levelOrderTraversal(root);
                break;
            case 6:
                printf("Original Tree In-order Traversal: ");
                inorderTraversal(root);
                printf("\n");
                break;
            case 7: {
                struct node *mirrorRoot = cloneTree(root);
                mirrorImage(mirrorRoot);
                printf("Mirror Image In-order Traversal: ");
                inorderTraversal(mirrorRoot);
                printf("\n");
                break;
            }
            case 8:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice!\n");
        }
    }

    return 0;
}


       Write a Program to create a Binary Tree and perform following Non-recursive operations on it. a. Postorder Traversal  c. Display Leaf Nodes d. Mirror Image
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
void postorderNonRecursive(struct node *root);
void displayLeafNodes(struct node *root);
void mirrorImage(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);

// Create a new node for the binary tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Perform postorder traversal of the binary tree (non-recursive)
void postorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack1 = NULL;
    struct stackNode *stack2 = NULL;
    push(&stack1, root);

    while (stack1 != NULL) {
        struct node *current = pop(&stack1);
        push(&stack2, current);

        if (current->left != NULL) {
            push(&stack1, current->left);
        }
        if (current->right != NULL) {
            push(&stack1, current->right);
        }
    }

    printf("Postorder Traversal: ");
    while (stack2 != NULL) {
        struct node *temp = pop(&stack2);
        printf("%d ", temp->data);
    }
    printf("\n");
}

// Display leaf nodes of the binary tree
void displayLeafNodes(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    printf("Leaf Nodes: ");
    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        if (current->left == NULL && current->right == NULL) {
            printf("%d ", current->data);
        }
        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Generate the mirror image of the binary tree
void mirrorImage(struct node *root) {
    if (root == NULL) {
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        struct node *temp = current->left;
        current->left = current->right;
        current->right = temp;

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 12);
    root = insert(root, 18);

    // Perform postorder traversal
    printf("Postorder Traversal: ");
    postorderNonRecursive(root);

    // Display leaf nodes
    displayLeafNodes(root);

    // Generate mirror image
    printf("Generating Mirror Image...\n");
    mirrorImage(root);
    printf("Mirror Image generated successfully.\n");

    return 0;
}



       Write a Program to create a Binary Search Tree and perform following non-recursive operations on it. a. Inorder Traversal b. Display Number of Leaf Nodes c. Mirror Image
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
void postorderNonRecursive(struct node *root);
void displayLeafNodes(struct node *root);
void mirrorImage(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);
struct node* cloneTree(struct node *root);
void inorderTraversal(struct node *root);

// Create a new node for the binary tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Perform postorder traversal of the binary tree (non-recursive)
void postorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack1 = NULL;
    struct stackNode *stack2 = NULL;
    push(&stack1, root);

    while (stack1 != NULL) {
        struct node *current = pop(&stack1);
        push(&stack2, current);

        if (current->left != NULL) {
            push(&stack1, current->left);
        }
        if (current->right != NULL) {
            push(&stack1, current->right);
        }
    }

    printf("Postorder Traversal: ");
    while (stack2 != NULL) {
        struct node *temp = pop(&stack2);
        printf("%d ", temp->data);
    }
    printf("\n");
}

// Display leaf nodes of the binary tree
void displayLeafNodes(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    printf("Leaf Nodes: ");
    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        if (current->left == NULL && current->right == NULL) {
            printf("%d ", current->data);
        }
        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Generate the mirror image of the binary tree
void mirrorImage(struct node *root) {
    if (root == NULL) {
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        struct node *temp = current->left;
        current->left = current->right;
        current->right = temp;

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

// Clone a binary tree
struct node* cloneTree(struct node *root) {
    if (root == NULL) {
        return NULL;
    }
    struct node *newNode = createNode(root->data);
    newNode->left = cloneTree(root->left);
    newNode->right = cloneTree(root->right);
    return newNode;
}

// Perform in-order traversal to display the tree
void inorderTraversal(struct node *root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);
        inorderTraversal(root->right);
    }
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 12);
    root = insert(root, 18);

    // Display the original tree
    printf("Original Tree In-order Traversal: ");
    inorderTraversal(root);
    printf("\n");

    // Create a mirror image of the tree
    struct node *mirrorRoot = cloneTree(root);
    mirrorImage(mirrorRoot);

    // Display the mirror image tree
    printf("Mirror Image Tree In-order Traversal: ");
    inorderTraversal(mirrorRoot);
    printf("\n");

    return 0;
}


       Write a Program to create a Binary Search Tree and perform following non-recursive operations on it. a. Preorder Traversal b. Display total Number of Nodes C. Display Leaf nodes.
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
void preorderNonRecursive(struct node *root);
int countNodes(struct node *root);
void displayLeafNodes(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Perform preorder traversal of the binary search tree (non-recursive)
void preorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack = NULL;
    push(&stack, root);

    printf("Preorder Traversal: ");
    while (stack != NULL) {
        struct node *current = pop(&stack);
        printf("%d ", current->data);

        if (current->right != NULL) {
            push(&stack, current->right);
        }
        if (current->left != NULL) {
            push(&stack, current->left);
        }
    }
    printf("\n");
}

// Count the total number of nodes in the binary search tree
int countNodes(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    int count = 0;
    struct stackNode *stack = NULL;
    push(&stack, root);

    while (stack != NULL) {
        struct node *current = pop(&stack);
        count++;

        if (current->right != NULL) {
            push(&stack, current->right);
        }
        if (current->left != NULL) {
            push(&stack, current->left);
        }
    }
    return count;
}

// Display the leaf nodes of the binary search tree
void displayLeafNodes(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack = NULL;
    push(&stack, root);

    printf("Leaf Nodes: ");
    while (stack != NULL) {
        struct node *current = pop(&stack);
        if (current->left == NULL && current->right == NULL) {
            printf("%d ", current->data);
        }
        if (current->right != NULL) {
            push(&stack, current->right);
        }
        if (current->left != NULL) {
            push(&stack, current->left);
        }
    }
    printf("\n");
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary search tree
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 12);
    root = insert(root, 18);

    // Perform preorder traversal
    preorderNonRecursive(root);

    // Display the total number of nodes
    printf("Total Number of Nodes: %d\n", countNodes(root));

    // Display the leaf nodes
    displayLeafNodes(root);

    return 0;
}



       Write a Program to create a Binary Search Tree and perform deletion of a node from it. Also display the tree in nonrecursive postorder way.
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
struct node* deleteNode(struct node *root, int key);
void postorderNonRecursive(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Delete a node from the binary search tree
struct node* deleteNode(struct node *root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }
        struct node *temp = root->right;
        while (temp->left != NULL) {
            temp = temp->left;
        }
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Perform postorder traversal of the binary search tree (non-recursive)
void postorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack1 = NULL, *stack2 = NULL;
    push(&stack1, root);

    while (stack1 != NULL) {
        struct node *current = pop(&stack1);
        push(&stack2, current);

        if (current->left != NULL) {
            push(&stack1, current->left);
        }
        if (current->right != NULL) {
            push(&stack1, current->right);
        }
    }

    printf("Postorder Traversal: ");
    while (stack2 != NULL) {
        struct node *current = pop(&stack2);
        printf("%d ", current->data);
    }
    printf("\n");
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary search tree
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 12);
    root = insert(root, 18);

    // Perform postorder traversal
    postorderNonRecursive(root);

    // Delete a node from the binary search tree
    int key = 15;
    root = deleteNode(root, key);
    printf("Node with key %d deleted from the tree.\n", key);

    // Perform postorder traversal after deletion
        printf("Postorder Traversal after deletion: ");
    postorderNonRecursive(root);

    return 0;
}

// User input
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
struct node* deleteNode(struct node *root, int key);
void postorderNonRecursive(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Delete a node from the binary search tree
struct node* deleteNode(struct node *root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }
        struct node *temp = root->right;
        while (temp->left != NULL) {
            temp = temp->left;
        }
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Perform postorder traversal of the binary search tree (non-recursive)
void postorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack1 = NULL, *stack2 = NULL;
    push(&stack1, root);

    while (stack1 != NULL) {
        struct node *current = pop(&stack1);
        push(&stack2, current);

        if (current->left != NULL) {
            push(&stack1, current->left);
        }
        if (current->right != NULL) {
            push(&stack1, current->right);
        }
    }

    printf("Postorder Traversal: ");
    while (stack2 != NULL) {
        struct node *current = pop(&stack2);
        printf("%d ", current->data);
    }
    printf("\n");
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

int main() {
    struct node *root = NULL;
    int choice, data, key;

    while (1) {
        printf("\nMenu:\n");
        printf("1. Insert\n");
        printf("2. Delete\n");
        printf("3. Postorder Traversal\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the data to insert: ");
                scanf("%d", &data);
                root = insert(root, data);
                break;
            case 2:
                printf("Enter the key to delete: ");
                scanf("%d", &key);
                root = deleteNode(root, key);
                printf("Node with key %d deleted from the tree.\n", key);
                break;
            case 3:
                printf("Postorder Traversal: ");
                postorderNonRecursive(root);
                break;
            case 4:
                exit(0);
                break;
            default:
                printf("Invalid choice!\n");
                break;
        }
    }

    return 0;
}



       Write a Program to create a Binary Search Tree and display it levelwise. Also perform deletion of a node from it.
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
void levelOrderTraversal(struct node *root);
struct node* deleteNode(struct node *root, int key);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Perform level-wise traversal of the binary search tree (non-recursive)
void levelOrderTraversal(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    printf("Level-wise Display:\n");
    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        printf("%d ", current->data);

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Delete a node from the binary search tree
struct node* deleteNode(struct node *root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        // Node with only one child or no child
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }

        // Node with two children: Get the inorder successor (smallest in the right subtree)
        struct node *temp = root->right;
        while (temp->left != NULL) {
            temp = temp->left;
        }

        // Copy the inorder successor's content to this node
        root->data = temp->data;

        // Delete the inorder successor
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary search tree
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 12);
    root = insert(root, 18);

    // Display the tree level-wise
    levelOrderTraversal(root);

    // Delete a node from the tree
    int key;
    printf("Enter the key to delete from the tree: ");
    scanf("%d", &key);
    root = deleteNode(root, key);

    // Display the tree level-wise after deletion
    levelOrderTraversal(root);

    return 0;
}


       Write a Program to create a Binary Search Tree and display its mirror image with and without disturbing the original tree. Also display height of a tree using nonrecursion.
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
typedef struct Node {
    int data;
    struct Node *left, *right;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node in the BST
Node* insert(Node* root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Function to print the BST in-order
void inorder(Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// Function to create a mirror image of the BST
Node* mirror(Node* root) {
    if (root == NULL) {
        return NULL;
    }
    Node* mirrorNode = createNode(root->data);
    mirrorNode->left = mirror(root->right);
    mirrorNode->right = mirror(root->left);
    return mirrorNode;
}

// Function to find the height of the BST using level-order traversal (non-recursive)
int height(Node* root) {
    if (root == NULL) {
        return 0;
    }
    int height = 0;
    Node* queue[100]; // Assuming the tree height won't exceed 100 levels
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (front < rear) {
        int nodeCount = rear - front;
        height++;
        while (nodeCount > 0) {
            Node* node = queue[front++];
            if (node->left) {
                queue[rear++] = node->left;
            }
            if (node->right) {
                queue[rear++] = node->right;
            }
            nodeCount--;
        }
    }
    return height;
}

// Main function
int main() {
    Node* root = NULL;
    int choice, data;

    while (1) {
        printf("\n1. Insert\n2. Display In-order\n3. Display Mirror In-order\n4. Display Height\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the data to insert: ");
                scanf("%d", &data);
                root = insert(root, data);
                break;
            case 2:
                printf("In-order display of BST: ");
                inorder(root);
                printf("\n");
                break;
            case 3: {
                Node* mirrorRoot = mirror(root);
                printf("In-order display of Mirror Image of BST: ");
                inorder(mirrorRoot);
                printf("\n");
                free(mirrorRoot); // Free the mirror tree to avoid memory leak
                break;
            }
            case 4:
                printf("Height of the BST: %d\n", height(root));
                break;
            case 5:
                exit(0);
                break;
            default:
                printf("Invalid choice!\n");
                break;
        }
    }

    return 0;
}

       Write a program to efficiently search a particular employee record by using Tree data structure. Also sort the data on emp-id in ascending order.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// Definition of the employee structure
struct employee {
    int emp_id;
    char name[50];
    struct employee *left, *right;
};

// Function prototypes
struct employee* createEmployee(int emp_id, const char *name);
struct employee* insertEmployee(struct employee *root, int emp_id, const char *name);
struct employee* searchEmployee(struct employee *root, int emp_id);
void inorderTraversal(struct employee *root);

// Create a new employee node
struct employee* createEmployee(int emp_id, const char *name) {
    struct employee *newEmployee = (struct employee *)malloc(sizeof(struct employee));
    if (newEmployee == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newEmployee->emp_id = emp_id;
    strcpy(newEmployee->name, name);
    newEmployee->left = NULL;
    newEmployee->right = NULL;
    return newEmployee;
}

// Insert an employee record into the binary search tree
struct employee* insertEmployee(struct employee *root, int emp_id, const char *name) {
    if (root == NULL) {
        return createEmployee(emp_id, name);
    }
    if (emp_id < root->emp_id) {
        root->left = insertEmployee(root->left, emp_id, name);
    } else if (emp_id > root->emp_id) {
        root->right = insertEmployee(root->right, emp_id, name);
    }
    return root;
}

// Search for an employee record by employee ID
struct employee* searchEmployee(struct employee *root, int emp_id) {
    if (root == NULL || root->emp_id == emp_id) {
        return root;
    }
    if (emp_id < root->emp_id) {
        return searchEmployee(root->left, emp_id);
    }
    return searchEmployee(root->right, emp_id);
}

// Perform inorder traversal of the binary search tree to sort employee records by emp_id
void inorderTraversal(struct employee *root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("Employee ID: %d, Name: %s\n", root->emp_id, root->name);
        inorderTraversal(root->right);
    }
}

int main() {
    struct employee *root = NULL;

    // Insert employee records into the binary search tree
    root = insertEmployee(root, 10, "John");
    root = insertEmployee(root, 7, "Alice");
    root = insertEmployee(root, 12, "Bob");
    root = insertEmployee(root, 5, "Eve");
    root = insertEmployee(root, 11, "Mike");

    // Search for an employee record by employee ID
    int search_id = 12;
    struct employee *foundEmployee = searchEmployee(root, search_id);
    if (foundEmployee != NULL) {
        printf("Employee ID: %d, Name: %s\n", foundEmployee->emp_id, foundEmployee->name);
    } else {
        printf("Employee with ID %d not found.\n", search_id);
    }

    // Display sorted employee records by emp_id
    printf("\nSorted Employee Records (by emp_id):\n");
    inorderTraversal(root);

    return 0;
}


  Write a Program to create Inorder Threaded Binary Tree and Traverse it in Preorder way.
________________________________________

       Write a Program to create Inorder Threaded Binary Tree and Traverse it in Inorder way.
________________________________________

       Write a Program to implement AVL tree and perform different rotations on it and display it Levelwise.
#include <stdio.h>  
#include <stdlib.h>  
   
struct Node  
{  
    int key;  
    struct Node *left;  
    struct Node *right;  
    int height;  
};  
   
int getHeight(struct Node *n){  
    if(n==NULL)  
        return 0;  
    return n->height;  
}  
   
struct Node *createNode(int key){  
    struct Node* node = (struct Node *) malloc(sizeof(struct Node));  
    node->key = key;  
    node->left = NULL;  
    node->right = NULL;  
    node->height = 1;  
    return node;  
}  
   
int max (int a, int b){  
    return (a>b)?a:b;  
}  
   
int getBalanceFactor(struct Node * n){  
    if(n==NULL){  
        return 0;  
    }  
    return getHeight(n->left) - getHeight(n->right);  
}  
   
struct Node* rightRotate(struct Node* y){  
    struct Node* x = y->left;  
    struct Node* T2 = x->right;  
   
    x->right = y;  
    y->left = T2;  
   
    x->height = max(getHeight(x->right), getHeight(x->left)) + 1;  
    y->height = max(getHeight(y->right), getHeight(y->left)) + 1;  
   
    return x;  
}  
   
struct Node* leftRotate(struct Node* x){  
    struct Node* y = x->right;  
    struct Node* T2 = y->left;  
   
    y->left = x;  
    x->right = T2;  
   
    x->height = max(getHeight(x->right), getHeight(x->left)) + 1;  
    y->height = max(getHeight(y->right), getHeight(y->left)) + 1;  
   
    return y;  
}  
   
struct Node *insert(struct Node* node, int key){  
    if (node == NULL)  
        return  createNode(key);  
   
    if (key < node->key)  
        node->left  = insert(node->left, key);  
    else if (key > node->key)  
        node->right = insert(node->right, key);  
   
    node->height = 1 + max(getHeight(node->left), getHeight(node->right));  
    int bf = getBalanceFactor(node);  
   
    // Left Left Case  
        if(bf>1 && key < node->left->key){  
            return rightRotate(node);  
        }  
    // Right Right Case  
        if(bf<-1 && key > node->right->key){  
            return leftRotate(node);  
        }  
    // Left Right Case  
    if(bf>1 && key > node->left->key){  
            node->left = leftRotate(node->left);  
            return rightRotate(node);  
        }  
    // Right Left Case  
    if(bf<-1 && key < node->right->key){  
            node->right = rightRotate(node->right);  
            return leftRotate(node);  
        }  
    return node;  
}  
int height(struct Node* node)
{
    if (node == NULL)
        return 0;
    else {
        
        // Compute the height of each subtree
        int lheight = height(node->left);
        int rheight = height(node->right);

        // Use the larger one
        if (lheight > rheight)
            return (lheight + 1);
        else
            return (rheight + 1);
    }
}

void printCurrentLevel(struct Node* root, int level)
{
    if (root == NULL)
        return;
    if (level == 1)
        printf("%d ", root->key);
    else if (level > 1) {
        printCurrentLevel(root->left, level - 1);
        printCurrentLevel(root->right, level - 1);
    }
}

void levelOrder(struct Node *root)
{   
    int h = height(root);
    int i;
    for (i = 1; i <= h; i++){
        printCurrentLevel(root, i);
        printf("\n");
    }
    printf("\n");
}  
   
int main(){  
    struct Node * root = NULL;  
    while (1)
    {
        int choice, num;
        printf("Press 1 to Insert a node\n");
        printf("Press 2 to Display the tree Levelwise\n");
        printf("Press 3 to Exit\n");
        printf("Enter your choice:\n");

        scanf("%d",&choice);

    switch (choice) {
    case 1: {
        int key;
        printf("Enter key:\n");
        scanf("%d",&key);
        root = insert(root, key);
        break;
    }
    case 2: {
        levelOrder(root);
        break;
    }
    case 3: {
        return 0;
    }
    default:
        printf("wrong Input\n");
    }
    }
    return 0;
    
} 

Write a Program to accept a graph from user and represent it with Adjacency Matrix and perform BFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 20

int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES];
int visited[MAX_VERTICES];
int queue[MAX_VERTICES];
int front = -1, rear = -1;
int vertices;

void createGraph()
{
    int i, j;
    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    printf("Enter the adjacency matrix:\n");
    for (i = 0; i < vertices; i++)
    {
        printf("Enter adjacency for vertex %d: ", i);
        for (j = 0; j < vertices; j++)
        {
            scanf("%d", &adjacencyMatrix[i][j]);
        }
    }
}

void initializeVisited()
{
    int i;
    for (i = 0; i < vertices; i++)
    {
        visited[i] = 0;
    }
}

void enqueue(int vertex)
{
    if (rear == MAX_VERTICES - 1)
    {
        printf("Queue Overflow!\n");
    }
    else
    {
        if (front == -1)
        {
            front = 0;
        }
        rear++;
        queue[rear] = vertex;
    }
}

int dequeue()
{
    int vertex;
    if (front == -1 || front > rear)
    {
        printf("Queue Underflow!\n");
        return -1;
    }
    else
    {
        vertex = queue[front];
        front++;
        return vertex;
    }
}

int isQueueEmpty()
{
    if (front == -1 || front > rear)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

void DFS(int vertex)
{
    int i;
    printf("%d ", vertex);
    visited[vertex] = 1;
    for (i = 0; i < vertices; i++)
    {
        if (adjacencyMatrix[vertex][i] == 1 && !visited[i])
        {
            DFS(i);
        }
    }
}

void BFS(int vertex)
{
    int i, dequeueVertex;
    printf("%d ", vertex);
    visited[vertex] = 1;
    enqueue(vertex);

    while (!isQueueEmpty())
    {
        dequeueVertex = dequeue();
        for (i = 0; i < vertices; i++)
        {
            if (adjacencyMatrix[dequeueVertex][i] == 1 && !visited[i])
            {
                printf("%d ", i);
                visited[i] = 1;
                enqueue(i);
            }
        }
    }
}

int main()
{
    int choice, startVertex;

    while (1)
    {
        printf("\nMENU\n");
        printf("1. Create Graph\n");
        printf("2. DFS\n");
        printf("3. BFS\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            createGraph();
            break;
        case 2:
            initializeVisited();
            printf("Enter the starting vertex for DFS: ");
            scanf("%d", &startVertex);
            printf("DFS Traversal: ");
            DFS(startVertex);
            printf("\n");
            break;
        case 3:
            initializeVisited();
            printf("Enter the starting vertex for BFS: ");
            scanf("%d", &startVertex);
            printf("BFS Traversal: ");
            BFS(startVertex);
            printf("\n");
            break;
        case 4:
            printf("Exiting program...\n");
            exit(0);
        default:
            printf("Invalid choice! Please enter a valid option.\n");
        }
    }

    return 0;
}

Write a Program to accept a graph from user and represent it with Adjacency Lists and perform BFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

struct AdjListNode {
    int dest;
    struct AdjListNode* next;
};

struct AdjList {
    struct AdjListNode* head;
};

struct Graph {
    int V;
    struct AdjList* array;
};

struct AdjListNode* newAdjListNode(int dest) {
    struct AdjListNode* newNode = (struct AdjListNode*)malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->next = NULL;
    return newNode;
}

struct Graph* createGraph(int V) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;
    graph->array = (struct AdjList*)malloc(V * sizeof(struct AdjList));
    for (int i = 0; i < V; ++i)
        graph->array[i].head = NULL;
    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    struct AdjListNode* newNode = newAdjListNode(dest);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;

   
    newNode = newAdjListNode(src);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

void DFS(struct Graph* graph, int start) {
    int* visited = (int*)calloc(graph->V, sizeof(int));
    int stack[graph->V];
    int top = -1;

    visited[start] = 1;
    stack[++top] = start;

    while (top != -1) {
        int current = stack[top--];
        printf("%d ", current);

        struct AdjListNode* temp = graph->array[current].head;
        while (temp != NULL) {
            if (!visited[temp->dest]) {
                visited[temp->dest] = 1;
                stack[++top] = temp->dest;
            }
            temp = temp->next;
        }
    }

    free(visited);
}

void BFS(struct Graph* graph, int start) {
    int* visited = (int*)calloc(graph->V, sizeof(int));
    int queue[graph->V];
    int front = 0, rear = 0;

    visited[start] = 1;
    queue[rear++] = start;

    while (front < rear) {
        int current = queue[front++];
        printf("%d ", current);

        struct AdjListNode* temp = graph->array[current].head;
        while (temp != NULL) {
            if (!visited[temp->dest]) {
                visited[temp->dest] = 1;
                queue[rear++] = temp->dest;
            }
            temp = temp->next;
        }
    }

    free(visited);
}

void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Add Edge\n");
    printf("2. Depth First Search (DFS)\n");
    printf("3. Breadth First Search (BFS)\n");
    printf("4. Exit\n");
}

int main() {
    int V, choice, src, dest;
    printf("Enter the number of vertices: ");
    scanf("%d", &V);

    struct Graph* graph = createGraph(V);

    while (1) {
        displayMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter source and destination vertices (0 to %d): ", V - 1);
                scanf("%d %d", &src, &dest);
                if (src >= 0 && src < V && dest >= 0 && dest < V)
                    addEdge(graph, src, dest);
                else
                    printf("Invalid vertices! Please enter vertices within the range.\n");
                break;
            case 2:
                printf("DFS Traversal: ");
                DFS(graph, 0);
                printf("\n");
                break;
            case 3:
                printf("BFS Traversal: ");
                BFS(graph, 0);
                printf("\n");
                break;
            case 4:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice! Please enter a valid option.\n");
        }
    }

    return 0;
}

Write a Program to accept a graph from user and represent it with Adjacency Matrix and perform DFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 20

int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES];
int visited[MAX_VERTICES];
int queue[MAX_VERTICES];
int front = -1, rear = -1;
int vertices;

void createGraph()
{
    int i, j;
    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    printf("Enter the adjacency matrix:\n");
    for (i = 0; i < vertices; i++)
    {
        printf("Enter adjacency for vertex %d: ", i);
        for (j = 0; j < vertices; j++)
        {
            scanf("%d", &adjacencyMatrix[i][j]);
        }
    }
}

void initializeVisited()
{
    int i;
    for (i = 0; i < vertices; i++)
    {
        visited[i] = 0;
    }
}

void enqueue(int vertex)
{
    if (rear == MAX_VERTICES - 1)
    {
        printf("Queue Overflow!\n");
    }
    else
    {
        if (front == -1)
        {
            front = 0;
        }
        rear++;
        queue[rear] = vertex;
    }
}

int dequeue()
{
    int vertex;
    if (front == -1 || front > rear)
    {
        printf("Queue Underflow!\n");
        return -1;
    }
    else
    {
        vertex = queue[front];
        front++;
        return vertex;
    }
}

int isQueueEmpty()
{
    if (front == -1 || front > rear)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

void DFS(int vertex)
{
    int i;
    printf("%d ", vertex);
    visited[vertex] = 1;
    for (i = 0; i < vertices; i++)
    {
        if (adjacencyMatrix[vertex][i] == 1 && !visited[i])
        {
            DFS(i);
        }
    }
}

void BFS(int vertex)
{
    int i, dequeueVertex;
    printf("%d ", vertex);
    visited[vertex] = 1;
    enqueue(vertex);

    while (!isQueueEmpty())
    {
        dequeueVertex = dequeue();
        for (i = 0; i < vertices; i++)
        {
            if (adjacencyMatrix[dequeueVertex][i] == 1 && !visited[i])
            {
                printf("%d ", i);
                visited[i] = 1;
                enqueue(i);
            }
        }
    }
}

int main()
{
    int choice, startVertex;

    while (1)
    {
        printf("\nMENU\n");
        printf("1. Create Graph\n");
        printf("2. DFS\n");
        printf("3. BFS\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            createGraph();
            break;
        case 2:
            initializeVisited();
            printf("Enter the starting vertex for DFS: ");
            scanf("%d", &startVertex);
            printf("DFS Traversal: ");
            DFS(startVertex);
            printf("\n");
            break;
        case 3:
            initializeVisited();
            printf("Enter the starting vertex for BFS: ");
            scanf("%d", &startVertex);
            printf("BFS Traversal: ");
            BFS(startVertex);
            printf("\n");
            break;
        case 4:
            printf("Exiting program...\n");
            exit(0);
        default:
            printf("Invalid choice! Please enter a valid option.\n");
        }
    }

    return 0;
}

Write a Program to accept a graph from user and represent it with Adjacency Lists and perform DFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

struct AdjListNode {
    int dest;
    struct AdjListNode* next;
};

struct AdjList {
    struct AdjListNode* head;
};

struct Graph {
    int V;
    struct AdjList* array;
};

struct AdjListNode* newAdjListNode(int dest) {
    struct AdjListNode* newNode = (struct AdjListNode*)malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->next = NULL;
    return newNode;
}

struct Graph* createGraph(int V) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;
    graph->array = (struct AdjList*)malloc(V * sizeof(struct AdjList));
    for (int i = 0; i < V; ++i)
        graph->array[i].head = NULL;
    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    struct AdjListNode* newNode = newAdjListNode(dest);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;

   
    newNode = newAdjListNode(src);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

void DFS(struct Graph* graph, int start) {
    int* visited = (int*)calloc(graph->V, sizeof(int));
    int stack[graph->V];
    int top = -1;

    visited[start] = 1;
    stack[++top] = start;

    while (top != -1) {
        int current = stack[top--];
        printf("%d ", current);

        struct AdjListNode* temp = graph->array[current].head;
        while (temp != NULL) {
            if (!visited[temp->dest]) {
                visited[temp->dest] = 1;
                stack[++top] = temp->dest;
            }
            temp = temp->next;
        }
    }

    free(visited);
}

void BFS(struct Graph* graph, int start) {
    int* visited = (int*)calloc(graph->V, sizeof(int));
    int queue[graph->V];
    int front = 0, rear = 0;

    visited[start] = 1;
    queue[rear++] = start;

    while (front < rear) {
        int current = queue[front++];
        printf("%d ", current);

        struct AdjListNode* temp = graph->array[current].head;
        while (temp != NULL) {
            if (!visited[temp->dest]) {
                visited[temp->dest] = 1;
                queue[rear++] = temp->dest;
            }
            temp = temp->next;
        }
    }

    free(visited);
}

void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Add Edge\n");
    printf("2. Depth First Search (DFS)\n");
    printf("3. Breadth First Search (BFS)\n");
    printf("4. Exit\n");
}

int main() {
    int V, choice, src, dest;
    printf("Enter the number of vertices: ");
    scanf("%d", &V);

    struct Graph* graph = createGraph(V);

    while (1) {
        displayMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter source and destination vertices (0 to %d): ", V - 1);
                scanf("%d %d", &src, &dest);
                if (src >= 0 && src < V && dest >= 0 && dest < V)
                    addEdge(graph, src, dest);
                else
                    printf("Invalid vertices! Please enter vertices within the range.\n");
                break;
            case 2:
                printf("DFS Traversal: ");
                DFS(graph, 0);
                printf("\n");
                break;
            case 3:
                printf("BFS Traversal: ");
                BFS(graph, 0);
                printf("\n");
                break;
            case 4:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice! Please enter a valid option.\n");
        }
    }

    return 0;
}

     Write a Program to implement Prim’s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

typedef struct Node {
    int vertex;
    int weight;
    struct Node* next;
} Node;

typedef struct {
    Node** head;
    int vertices;
} Graph;

Node* createNode(int vertex, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = vertex;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

Graph* createGraph(int vertices) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->vertices = vertices;
    graph->head = (Node**)malloc(vertices * sizeof(Node*));
    for (int i = 0; i < vertices; i++) {
        graph->head[i] = NULL;
    }
    return graph;
}

void addEdge(Graph* graph, int src, int dest, int weight) {
    Node* newNode = createNode(dest, weight);
    newNode->next = graph->head[src];
    graph->head[src] = newNode;

    newNode = createNode(src, weight);
    newNode->next = graph->head[dest];
    graph->head[dest] = newNode;
}

int minKey(int key[], int mstSet[], int vertices) {
    int min = INT_MAX, minIndex;
    for (int v = 0; v < vertices; v++) {
        if (mstSet[v] == 0 && key[v] < min) {
            min = key[v];
            minIndex = v;
        }
    }
    return minIndex;
}

void printMST(int parent[], int vertices, Graph* graph) {
    printf("Edge \tWeight\n");
    for (int i = 1; i < vertices; i++) {
        for (Node* node = graph->head[i]; node != NULL; node = node->next) {
            if (node->vertex == parent[i]) {
                printf("%d - %d \t%d \n", parent[i], i, node->weight);
                break;
            }
        }
    }
}

void primMST(Graph* graph) {
    int vertices = graph->vertices;
    int parent[vertices];
    int key[vertices];
    int mstSet[vertices];

    for (int i = 0; i < vertices; i++) {
        key[i] = INT_MAX;
        mstSet[i] = 0;
    }

    key[0] = 0;
    parent[0] = -1;

    for (int count = 0; count < vertices - 1; count++) {
        int u = minKey(key, mstSet, vertices);
        mstSet[u] = 1;

        for (Node* node = graph->head[u]; node != NULL; node = node->next) {
            int v = node->vertex;
            if (mstSet[v] == 0 && node->weight < key[v]) {
                parent[v] = u;
                key[v] = node->weight;
            }
        }
    }

    printMST(parent, vertices, graph);
}

int main() {
    int vertices, edges;
    printf("Enter number of vertices: ");
    scanf("%d", &vertices);
    printf("Enter number of edges: ");
    scanf("%d", &edges);

    Graph* graph = createGraph(vertices);

    printf("Enter edges (src dest weight):\n");
    for (int i = 0; i < edges; i++) {
        int src, dest, weight;
        scanf("%d %d %d", &src, &dest, &weight);
        if (src >= vertices || dest >= vertices || src < 0 || dest < 0) {
            printf("Invalid edge!\n");
            i--;
        } else {
            addEdge(graph, src, dest, weight);
        }
    }

    primMST(graph);

    for (int i = 0; i < vertices; i++) {
        Node* node = graph->head[i];
        while (node) {
            Node* temp = node;
            node = node->next;
            free(temp);
        }
    }
    free(graph->head);
    free(graph);

    return 0;
}
Write a Program to implement Kruskals’s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency Matrix to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_VERTICES 100

int comparator(const void* p1, const void* p2)
{
    const int (*x)[3] = p1;
    const int (*y)[3] = p2;

    return (*x)[2] - (*y)[2];
}

void makeSet(int parent[], int rank[], int n)
{
    for (int i = 0; i < n; i++)
    {
        parent[i] = i;
        rank[i] = 0;
    }
}

int findParent(int parent[], int component)
{
    if (parent[component] == component)
        return component;

    return parent[component] = findParent(parent, parent[component]);
}


void unionSet(int u, int v, int parent[], int rank[], int n)
{
    // Finding the parents
    u = findParent(parent, u);
    v = findParent(parent, v);

    if (rank[u] < rank[v])
    {
        parent[u] = v;
    }
    else if (rank[u] > rank[v])
    {
        parent[v] = u;
    }
    else
    {
        parent[v] = u;

        rank[u]++;
    }
}


void kruskalAlgo(int n, int edge[][3])
{
    
    qsort(edge, n, sizeof(edge[0]), comparator);

    int parent[n];
    int rank[n];

    makeSet(parent, rank, n);

    int minCost = 0;

    printf("Following are the edges in the constructed MST\n");
    for (int i = 0; i < n; i++)
    {
        int v1 = findParent(parent, edge[i][0]);
        int v2 = findParent(parent, edge[i][1]);
        int wt = edge[i][2];

        
        if (v1 != v2)
        {
            unionSet(v1, v2, parent, rank, n);
            minCost += wt;
            printf("%d -- %d == %d\n", edge[i][0],
                   edge[i][1], wt);
        }
    }

    printf("Minimum Cost Spanning Tree: %d\n", minCost);
}

void createAdjacencyMatrix(int numVertices, int adjacencyMatrix[][MAX_VERTICES])
{
    printf("Enter the adjacency matrix:\n");
    for (int i = 0; i < numVertices; i++)
    {
        for (int j = 0; j < numVertices; j++)
        {
            scanf("%d", &adjacencyMatrix[i][j]);
        }
    }
}

int main()
{
    int numVertices, numEdges;
    printf("Enter the number of vertices: ");
    scanf("%d", &numVertices);
    numEdges = numVertices * (numVertices - 1) / 2; // Assuming a complete graph

    int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES];
    createAdjacencyMatrix(numVertices, adjacencyMatrix);

    int edge[numEdges][3];
    int edgeCount = 0;

    // Converting adjacency matrix to edge list
    for (int i = 0; i < numVertices; i++)
    {
        for (int j = i + 1; j < numVertices; j++)
        {
            if (adjacencyMatrix[i][j] != 0)
            {
                edge[edgeCount][0] = i;
                edge[edgeCount][1] = j;
                edge[edgeCount][2] = adjacencyMatrix[i][j];
                edgeCount++;
            }
        }
    }

    kruskalAlgo(numEdges, edge);

    return 0;
}
Write a Program to implement Kruskal’s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct Node {
    int vertex;
    int weight;
    struct Node* next;
} Node;

Node* createNode(int vertex, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    newNode->vertex = vertex;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

void addEdge(Node** head, int vertex, int weight) {
    Node* newNode = createNode(vertex, weight);
    newNode->next = *head;
    *head = newNode;
}

void printAdjacencyList(int numVertices, Node* adjacencyList[]) {
    for (int i = 0; i < numVertices; i++) {
        Node* current = adjacencyList[i];
        printf("Adjacency list for vertex %d: ", i);
        while (current != NULL) {
            printf("(%d, %d) ", current->vertex, current->weight);
            current = current->next;
        }
        printf("\n");
    }
}

void freeAdjacencyList(int numVertices, Node* adjacencyList[]) {
    for (int i = 0; i < numVertices; i++) {
        Node* current = adjacencyList[i];
        while (current != NULL) {
            Node* temp = current;
            current = current->next;
            free(temp);
        }
    }
}

void createEdgeList(int numVertices, Node* adjacencyList[], int edge[][3], int *numEdges) {
    int edgeCount = 0;
    for (int i = 0; i < numVertices; i++) {
        Node* current = adjacencyList[i];
        while (current != NULL) {
            edge[edgeCount][0] = i;
            edge[edgeCount][1] = current->vertex;
            edge[edgeCount][2] = current->weight;
            edgeCount++;
            current = current->next;
        }
    }
    *numEdges = edgeCount;
}

int comparator(const void* p1, const void* p2) {
    const int (*x)[3] = p1;
    const int (*y)[3] = p2;
    return (*x)[2] - (*y)[2];
}

int findParent(int parent[], int component) {
    if (parent[component] == component)
        return component;
    return parent[component] = findParent(parent, parent[component]);
}

void unionSet(int u, int v, int parent[], int rank[], int n) {
    u = findParent(parent, u);
    v = findParent(parent, v);
    if (rank[u] < rank[v]) {
        parent[u] = v;
    } else if (rank[u] > rank[v]) {
        parent[v] = u;
    } else {
        parent[v] = u;
        rank[u]++;
    }
}

void kruskalAlgo(int numEdges, int edge[][3], int numVertices) {
    qsort(edge, numEdges, sizeof(edge[0]), comparator);

    int parent[numVertices];
    int rank[numVertices];
    int minCost = 0;

    for (int i = 0; i < numVertices; i++) {
        parent[i] = i;
        rank[i] = 0;
    }

    printf("Following are the edges in the constructed MST\n");
    for (int i = 0; i < numEdges; i++) {
        int u = findParent(parent, edge[i][0]);
        int v = findParent(parent, edge[i][1]);
        int weight = edge[i][2];

        if (u != v) {
            printf("%d -- %d == %d\n", edge[i][0], edge[i][1], weight);
            minCost += weight;
            unionSet(u, v, parent, rank, numVertices);
        }
    }

    printf("Minimum Cost Spanning Tree: %d\n", minCost);
}

int main() {
    int numVertices;
    printf("Enter the number of vertices: ");
    scanf("%d", &numVertices);

    Node* adjacencyList[numVertices];
    for (int i = 0; i < numVertices; i++) {
        adjacencyList[i] = NULL;
        printf("Enter adjacency list for vertex %d (destination weight format) (-1 to terminate): ", i);
        int vertex, weight;
        while (true) {
            scanf("%d", &vertex);
            if (vertex == -1)
                break;
            scanf("%d", &weight);
            addEdge(&adjacencyList[i], vertex, weight);
        }
    }

    printAdjacencyList(numVertices, adjacencyList);

    int numEdges = numVertices * numVertices; // Max possible edges for a complete graph
    int edge[numEdges][3];
    int actualNumEdges;
    createEdgeList(numVertices, adjacencyList, edge, &actualNumEdges);

    kruskalAlgo(actualNumEdges, edge, numVertices);

    freeAdjacencyList(numVertices, adjacencyList);

    return 0;
}
Write a Program to implement Dijkstra’s algorithm to find shortest distance between two nodes of a user defined graph. Use Adjacency List to represent a graph
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdbool.h>

#define V 9

struct Node {
    int vertex, weight;
    struct Node* next;
};

void dijkstra(struct Node* adjList[], int src) {
    int dist[V];
    bool sptSet[V];

    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;

    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int u = -1;
        int min_dist = INT_MAX;


        for (int v = 0; v < V; v++) {
            if (!sptSet[v] && dist[v] < min_dist) {
                u = v;
                min_dist = dist[v];
            }
        }

        if (u == -1)
            break;

        sptSet[u] = true;

        struct Node* current = adjList[u];
        while (current != NULL) {
            int v = current->vertex;
            int weight = current->weight;
            if (!sptSet[v] && dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
            }
            current = current->next;
        }
    }

    printf("Vertex \t\t Distance from Source\n");
    for (int i = 0; i < V; i++)
        printf("%d \t\t\t\t %d\n", i, dist[i]);
}

struct Node* createNode(int v, int weight) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->vertex = v;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

void addEdge(struct Node* adjList[], int src, int dest, int weight) {
    struct Node* newNode = createNode(dest, weight);
    newNode->next = adjList[src];
    adjList[src] = newNode;

    newNode = createNode(src, weight);
    newNode->next = adjList[dest];
    adjList[dest] = newNode;
}

int main() {
    int numEdges;
    printf("Enter the number of edges: ");
    scanf("%d", &numEdges);

    struct Node* adjList[V];
    for (int i = 0; i < V; i++)
        adjList[i] = NULL;

    printf("Enter edges along with their weights (source destination weight):\n");
    int source, destination, weight;
    for (int i = 0; i < numEdges; i++) {
        scanf("%d %d %d", &source, &destination, &weight);
        addEdge(adjList, source, destination, weight);
    }

    dijkstra(adjList, 0);

    return 0;
}
Write a Program to implement Dijkstra’s algorithm to find shortest distance between two nodes of a user defined graph. Use Adjacency Matrix to represent a graph
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>

int minDistance(int dist[], bool sptSet[], int V) {
    int min = INT_MAX, min_index;

    for (int v = 0; v < V; v++)
        if (sptSet[v] == false && dist[v] <= min)
            min = dist[v], min_index = v;

    return min_index;
}

void printSolution(int dist[], int V) {
    printf("Vertex \t\t Distance from Source\n");
    for (int i = 0; i < V; i++) {
        if (dist[i] == INT_MAX)
            printf("%d \t\t\t\t Infinite\n", i);
        else
            printf("%d \t\t\t\t %d\n", i, dist[i]);
    }
}

void dijkstra(int **graph, int src, int V) {
    int dist[V];
    bool sptSet[V];

    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;

    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, sptSet, V);

        sptSet[u] = true;

        for (int v = 0; v < V; v++)
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }

    printSolution(dist, V);
}

int main() {
    int V;
    printf("Enter the number of vertices in the graph: ");
    scanf("%d", &V);

    int **graph = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
        graph[i] = (int *)malloc(V * sizeof(int));

    printf("Enter the adjacency matrix of the graph (%d x %d):\n", V, V);
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    int src;
    printf("Enter the source vertex: ");
    scanf("%d", &src);

    dijkstra(graph, src, V);

    
    for (int i = 0; i < V; i++)
        free(graph[i]);
    free(graph);

    return 0;
}

________________________________________
WAP to implement Heap sort on 1D array of Student structure (contains student_name, student_roll_no, total_marks), with key as student_roll_no. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

// Define the Student structure
typedef struct {
    char student_name[50];
    int student_roll_no;
    float total_marks;
} Student;

// Function prototypes
void heapify(Student arr[], int n, int i, int *swap_count);
void heapSort(Student arr[], int n, int *swap_count);
void swap(Student *a, Student *b);

// Heapify function to maintain heap property
void heapify(Student arr[], int n, int i, int *swap_count) {
    int largest = i; // Initialize largest as root
    int left = 2 * i + 1; // left = 2*i + 1
    int right = 2 * i + 2; // right = 2*i + 2

    // If left child is larger than root
    if (left < n && arr[left].student_roll_no > arr[largest].student_roll_no)
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right].student_roll_no > arr[largest].student_roll_no)
        largest = right;

    // If largest is not root
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        (*swap_count)++;
        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest, swap_count);
    }
}

// Function to perform heap sort
void heapSort(Student arr[], int n, int *swap_count) {
    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i, swap_count);

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        swap(&arr[0], &arr[i]);
        (*swap_count)++;
        // Call max heapify on the reduced heap
        heapify(arr, i, 0, swap_count);
    }
}

// Function to swap two students
void swap(Student *a, Student *b) {
    Student temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int swap_count = 0;

    // Sample array of students
    Student students[] = {
        {"Alice", 3, 88.5},
        {"Bob", 1, 91.2},
        {"Charlie", 4, 75.0},
        {"David", 2, 82.3}
    };
    
    int n = sizeof(students) / sizeof(students[0]);

    // Perform heap sort
    heapSort(students, n, &swap_count);

    // Print sorted array
    printf("Sorted array by student_roll_no:\n");
    for (int i = 0; i < n; i++) {
        printf("Name: %s, Roll No: %d, Total Marks: %.2f\n", students[i].student_name, students[i].student_roll_no, students[i].total_marks);
    }

    // Print the number of swaps performed
    printf("Number of swaps performed: %d\n", swap_count);

    return 0;
}



WAP to implement Quick sort on 1D array of Employee structure (contains employee_name, emp_no, emp_salary), with key as emp_no. And count the number of swap performed.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char employee_name[50];
    int emp_no;
    float emp_salary;
} Employee;

int swap_count = 0;

void swap(Employee *a, Employee *b) {
    Employee temp = *a;
    *a = *b;
    *b = temp;
    swap_count++;
}

int partition(Employee arr[], int low, int high) {
    int pivot = arr[high].emp_no;
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr[j].emp_no < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(Employee arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int empNoExists(Employee arr[], int size, int emp_no) {
    for (int i = 0; i < size; i++) {
        if (arr[i].emp_no == emp_no) {
            return 1;
        }
    }
    return 0;
}

int main() {
    int n;
    printf("Enter the number of employees: ");
    if (scanf("%d", &n) != 1 || n <= 0) {
        printf("Invalid number of employees.\n");
        return 1;
    }

    Employee *arr = (Employee *)malloc(n * sizeof(Employee));
    if (arr == NULL) {
        printf("Memory allocation error.\n");
        return 1;
    }

    for (int i = 0; i < n; i++) {
        printf("Enter details for employee %d\n", i + 1);
        printf("Name: ");
        scanf("%s", arr[i].employee_name);
        printf("Employee Number: ");
        int emp_no;
        while (1) {
            if (scanf("%d", &emp_no) != 1) {
                printf("Invalid input for employee number. Try again: ");
                while (getchar() != '\n'); // Clear invalid input
            } else if (empNoExists(arr, i, emp_no)) {
                printf("Employee number already exists. Enter a unique employee number: ");
            } else {
                arr[i].emp_no = emp_no;
                break;
            }
        }
        printf("Salary: ");
        if (scanf("%f", &arr[i].emp_salary) != 1) {
            printf("Invalid input for salary.\n");
            free(arr);
            return 1;
        }
    }

    quickSort(arr, 0, n - 1);

    printf("Sorted list of employees based on employee number:\n");
    for (int i = 0; i < n; i++) {
        printf("Name: %s, Employee Number: %d, Salary: %.2f\n",
               arr[i].employee_name, arr[i].emp_no, arr[i].emp_salary);
    }

    printf("Number of swaps performed: %d\n", swap_count);

    free(arr);
    return 0;
}



Assume that an array A with n elements was sorted in an ascending order, but two of its elements swapped their positions by a mistake while maintaining the array. Write a code to identify the swapped pair of elements and their positions in the asymptotically best possible time. [Assume that all given elements are distinct integers.]

#include <stdio.h>

void findSwappedElements(int arr[], int n) {
    int x = -1, y = -1; 
    int i;

    for (i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            x = arr[i];
            break;
        }
    }

    for (i = n - 1; i > 0; i--) {
        if (arr[i] < arr[i - 1]) {
            y = arr[i];
            break;
        }
    }

    int posX = -1, posY = -1;
    for (i = 0; i < n; i++) {
        if (arr[i] == x) {
            posX = i;
        } else if (arr[i] == y) {
            posY = i;
        }
    }

    if (posX != -1 && posY != -1) {
        printf("The swapped elements are %d and %d\n", x, y);
        printf("Their positions are %d and %d\n", posX, posY);
    } else {
        printf("No swapped elements found.\n");
    }
}

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];
    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    findSwappedElements(arr, n);

    return 0;
}



Implement following hashing Techniques by assuming suitable input and Table Size.
a.	Linear Probing With Chaining Without Replacement
Also mention number of collisions occurred while inserting a Data in hash table.
#include <stdio.h>
#include <stdlib.h>

#define TABLE_SIZE 10 // Define the size of the hash table
#define EMPTY -1      // Define the marker for empty slots

typedef struct {
    int data;
    int chain;
} HashEntry;

HashEntry hashTable[TABLE_SIZE];
int collisionCount = 0;

// Hash function
int hashFunction(int key) {
    return key % TABLE_SIZE;
}

// Initialize the hash table
void initializeTable() {
    for (int i = 0; i < TABLE_SIZE; i++) {
        hashTable[i].data = EMPTY;
        hashTable[i].chain = EMPTY;
    }
}

// Function to insert data into the hash table
void insert(int key) {
    int index = hashFunction(key);
    
    if (hashTable[index].data == EMPTY) {
        hashTable[index].data = key;
    } else {
        collisionCount++;
        int originalIndex = index;
        while (hashTable[index].data != EMPTY) {
            index = (index + 1) % TABLE_SIZE;
            if (index == originalIndex) {
                printf("Hash table is full!\n");
                return;
            }
        }
        // Insert the new key
        hashTable[index].data = key;
        
        // Update the chain
        int chainIndex = hashFunction(key);
        while (hashTable[chainIndex].chain != EMPTY) {
            chainIndex = hashTable[chainIndex].chain;
        }
        hashTable[chainIndex].chain = index;
    }
}

// Function to display the hash table
void displayTable() {
    printf("Index\tData\tChain\n");
    for (int i = 0; i < TABLE_SIZE; i++) {
        printf("%d\t%d\t%d\n", i, hashTable[i].data, hashTable[i].chain);
    }
}

int main() {
    int data, n;
    initializeTable();

    printf("Enter the number of elements to insert: ");
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("Enter data %d: ", i + 1);
        scanf("%d", &data);
        insert(data);
    }

    displayTable();
    printf("Number of collisions: %d\n", collisionCount);

    return 0;
}



Implement following hashing Techniques by assuming suitable input and Table Size.
a.	Linear Probing With Chaining With Replacement
Also mention number of collisions occurred while inserting a Data in hash table.
#include <stdio.h>
#include <stdlib.h>

#define TABLE_SIZE 10 // Define the size of the hash table
#define EMPTY -1      // Define the marker for empty slots

typedef struct {
    int data;
    int chain;
} HashEntry;

HashEntry hashTable[TABLE_SIZE];
int collisionCount = 0;

// Hash function
int hashFunction(int key) {
    return key % TABLE_SIZE;
}

// Initialize the hash table
void initializeTable() {
    for (int i = 0; i < TABLE_SIZE; i++) {
        hashTable[i].data = EMPTY;
        hashTable[i].chain = EMPTY;
    }
}

// Function to insert data into the hash table
void insert(int key) {
    int index = hashFunction(key);
    
    if (hashTable[index].data == EMPTY) {
        hashTable[index].data = key;
    } else {
        collisionCount++;
        // If the current index contains an element with a different home position, replace it
        int currentIndex = index;
        int tempData = hashTable[currentIndex].data;
        int tempChain = hashTable[currentIndex].chain;

        if (hashFunction(tempData) != currentIndex) {
            hashTable[currentIndex].data = key;
            key = tempData;

            // Fix the chain of the displaced element
            int originalIndex = hashFunction(key);
            while (hashTable[originalIndex].chain != currentIndex) {
                originalIndex = hashTable[originalIndex].chain;
            }
            hashTable[originalIndex].chain = tempChain;
        }

        // Linear probing to find the next available slot
        while (hashTable[index].data != EMPTY) {
            index = (index + 1) % TABLE_SIZE;
        }
        
        // Insert the new key
        hashTable[index].data = key;

        // Update the chain for the original slot
        int chainIndex = hashFunction(key);
        while (hashTable[chainIndex].chain != EMPTY) {
            chainIndex = hashTable[chainIndex].chain;
        }
        hashTable[chainIndex].chain = index;
    }
}

// Function to display the hash table
void displayTable() {
    printf("Index\tData\tChain\n");
    for (int i = 0; i < TABLE_SIZE; i++) {
        printf("%d\t%d\t%d\n", i, hashTable[i].data, hashTable[i].chain);
    }
}

int main() {
    int data, n;
    initializeTable();

    printf("Enter the number of elements to insert: ");
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("Enter data %d: ", i + 1);
        scanf("%d", &data);
        insert(data);
    }

    displayTable();
    printf("Number of collisions: %d\n", collisionCount);

    return 0;
}
3. WAP to implement two stack using array and perform following operations on it. A. PUSH, B. POP, C. StackFull D. StackeEmpty E. Display Stack.

#include <stdio.h>
#include <stdlib.h>

#define MAX 3

typedef struct {
    int top1;
    int top2;
    int items[MAX];
} TwoStacks;

void initTwoStacks(TwoStacks *ts) {
    ts->top1 = -1;
    ts->top2 = MAX;
}

int isStack1Empty(TwoStacks *ts) {
    return ts->top1 == -1;
}

int isStack2Empty(TwoStacks *ts) {
    return ts->top2 == MAX;
}

int isStackFull(TwoStacks *ts) {
    return ts->top1 + 1 == ts->top2;
}

void pushStack1(TwoStacks *ts, int value) {
    if (isStackFull(ts)) {
        printf("Stack1 overflow\n");
        return;
    }
    ts->items[++ts->top1] = value;
}

void pushStack2(TwoStacks *ts, int value) {
    if (isStackFull(ts)) {
        printf("Stack2 overflow\n");
        return;
    }
    ts->items[--ts->top2] = value;
}

int popStack1(TwoStacks *ts) {
    if (isStack1Empty(ts)) {
        printf("Stack1 underflow\n");
        exit(1);
    }
    return ts->items[ts->top1--];
}

int popStack2(TwoStacks *ts) {
    if (isStack2Empty(ts)) {
        printf("Stack2 underflow\n");
        exit(1);
    }
    return ts->items[ts->top2++];
}

void displayStack1(TwoStacks *ts) {
    if (isStack1Empty(ts)) {
        printf("Stack1 is empty\n");
        return;
    }
    printf("Stack1 elements: ");
    for (int i = 0; i <= ts->top1; i++) {
        printf("%d ", ts->items[i]);
    }
    printf("\n");
}

void displayStack2(TwoStacks *ts) {
    if (isStack2Empty(ts)) {
        printf("Stack2 is empty\n");
        return;
    }
    printf("Stack2 elements: ");
    for (int i = MAX - 1; i >= ts->top2; i--) {
        printf("%d ", ts->items[i]);
    }
    printf("\n");
}

int main() {
    TwoStacks ts;
    initTwoStacks(&ts);

    int choice, value;
    while (1) {
        printf("\n1. Push to Stack1\n2. Push to Stack2\n3. Pop from Stack1\n4. Pop from Stack2\n");
        printf("5. Check if Stack is Full\n6. Check if Stack1 is Empty\n7. Check if Stack2 is Empty\n");
        printf("8. Display Stack1\n9. Display Stack2\n10. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to push to Stack1: ");
                scanf("%d", &value);
                pushStack1(&ts, value);
                break;
            case 2:
                printf("Enter value to push to Stack2: ");
                scanf("%d", &value);
                pushStack2(&ts, value);
                break;
            case 3:
                printf("Popped from Stack1: %d\n", popStack1(&ts));
                break;
            case 4:
                printf("Popped from Stack2: %d\n", popStack2(&ts));
                break;
            case 5:
                if (isStackFull(&ts)) {
                    printf("Both stacks are full\n");
                } else {
                    printf("Stacks are not full\n");
                }
                break;
            case 6:
                if (isStack1Empty(&ts)) {
                    printf("Stack1 is empty\n");
                } else {
                    printf("Stack1 is not empty\n");
                }
                break;
            case 7:
                if (isStack2Empty(&ts)) {
                    printf("Stack2 is empty\n");
                } else {
                    printf("Stack2 is not empty\n");
                }
                break;
            case 8:
                displayStack1(&ts);
                break;
            case 9:
                displayStack2(&ts);
                break;
            case 10:
                exit(0);
            default:
                printf("Invalid choice\n");
        }
    }

    return 0;
}

5. Write a Program to implement circular double ended queue where user can add and remove the elements from both front and rear of the queue.
#include <stdio.h>
#include <stdlib.h>

#define MAX 100

typedef struct {
    int front, rear;
    int items[MAX];
} Deque;

void initDeque(Deque *dq) {
    dq->front = -1;
    dq->rear = -1;
}

int isFull(Deque *dq) {
    return ((dq->front == 0 && dq->rear == MAX - 1) || (dq->front == dq->rear + 1));
}

int isEmpty(Deque *dq) {
    return (dq->front == -1);
}

void insertFront(Deque *dq, int value) {
    if (isFull(dq)) {
        printf("Deque is full\n");
        return;
    }

    if (dq->front == -1) {
        dq->front = 0;
        dq->rear = 0;
    } else if (dq->front == 0) {
        dq->front = MAX - 1;
    } else {
        dq->front--;
    }

    dq->items[dq->front] = value;
}

void insertRear(Deque *dq, int value) {
    if (isFull(dq)) {
        printf("Deque is full\n");
        return;
    }

    if (dq->rear == -1) {
        dq->front = 0;
        dq->rear = 0;
    } else if (dq->rear == MAX - 1) {
        dq->rear = 0;
    } else {
        dq->rear++;
    }

    dq->items[dq->rear] = value;
}

void deleteFront(Deque *dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty\n");
        return;
    }

    printf("Deleted %d from front\n", dq->items[dq->front]);

    if (dq->front == dq->rear) {
        dq->front = -1;
        dq->rear = -1;
    } else if (dq->front == MAX - 1) {
        dq->front = 0;
    } else {
        dq->front++;
    }
}

void deleteRear(Deque *dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty\n");
        return;
    }

    printf("Deleted %d from rear\n", dq->items[dq->rear]);

    if (dq->front == dq->rear) {
        dq->front = -1;
        dq->rear = -1;
    } else if (dq->rear == 0) {
        dq->rear = MAX - 1;
    } else {
        dq->rear--;
    }
}

void displayDeque(Deque *dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty\n");
        return;
    }

    printf("Deque elements: ");
    int i = dq->front;
    while (1) {
        printf("%d ", dq->items[i]);
        if (i == dq->rear) {
            break;
        }
        i = (i + 1) % MAX;
    }
    printf("\n");
}

int main() {
    Deque dq;
    initDeque(&dq);

    int choice, value;
    while (1) {
        printf("\n1. Insert at front\n2. Insert at rear\n3. Delete from front\n4. Delete from rear\n5. Display deque\n6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert at front: ");
                scanf("%d", &value);
                insertFront(&dq, value);
                break;
            case 2:
                printf("Enter value to insert at rear: ");
                scanf("%d", &value);
                insertRear(&dq, value);
                break;
            case 3:
                deleteFront(&dq);
                break;
            case 4:
                deleteRear(&dq);
                break;
            case 5:
                displayDeque(&dq);
                break;
            case 6:
                exit(0);
            default:
                printf("Invalid choice\n");
        }
    }

    return 0;
}

6. Write a Program to implement multiple two queues using array and perform following operations on it. A. Addq, B. Delq, C. Display Queue.
#include <stdio.h>
#include <stdlib.h>

#define MAX 100

typedef struct {
    int front1, rear1;
    int front2, rear2;
    int items[MAX];
} TwoQueues;

void initTwoQueues(TwoQueues *q) {
    q->front1 = -1;
    q->rear1 = -1;
    q->front2 = MAX;
    q->rear2 = MAX;
}

int isFull1(TwoQueues *q) {
    return q->rear1 + 1 == q->front2;
}

int isFull2(TwoQueues *q) {
    return q->rear2 - 1 == q->rear1;
}

int isEmpty1(TwoQueues *q) {
    return q->front1 == -1;
}

int isEmpty2(TwoQueues *q) {
    return q->front2 == MAX;
}

void addq1(TwoQueues *q, int value) {
    if (isFull1(q)) {
        printf("Queue1 overflow\n");
        return;
    }
    if (q->front1 == -1) {
        q->front1 = 0;
    }
    q->items[++q->rear1] = value;
}

void addq2(TwoQueues *q, int value) {
    if (isFull2(q)) {
        printf("Queue2 overflow\n");
        return;
    }
    if (q->front2 == MAX) {
        q->front2 = MAX - 1;
    }
    q->items[--q->rear2] = value;
}

int delq1(TwoQueues *q) {
    if (isEmpty1(q)) {
        printf("Queue1 underflow\n");
        exit(1);
    }
    int value = q->items[q->front1];
    if (q->front1 == q->rear1) {
        q->front1 = -1;
        q->rear1 = -1;
    } else {
        q->front1++;
    }
    return value;
}

int delq2(TwoQueues *q) {
    if (isEmpty2(q)) {
        printf("Queue2 underflow\n");
        exit(1);
    }
    int value = q->items[q->front2];
    if (q->front2 == q->rear2) {
        q->front2 = MAX;
        q->rear2 = MAX;
    } else {
        q->front2--;
    }
    return value;
}

void displayQueue1(TwoQueues *q) {
    if (isEmpty1(q)) {
        printf("Queue1 is empty\n");
        return;
    }
    printf("Queue1 elements: ");
    for (int i = q->front1; i <= q->rear1; i++) {
        printf("%d ", q->items[i]);
    }
    printf("\n");
}

void displayQueue2(TwoQueues *q) {
    if (isEmpty2(q)) {
        printf("Queue2 is empty\n");
        return;
    }
    printf("Queue2 elements: ");
    for (int i = q->front2; i >= q->rear2; i--) {
        printf("%d ", q->items[i]);
    }
    printf("\n");
}

int main() {
    TwoQueues q;
    initTwoQueues(&q);

    int choice, value, queueNumber;
    while (1) {
        printf("\n1. Add to Queue\n2. Delete from Queue\n3. Display Queue\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter queue number (1 or 2): ");
                scanf("%d", &queueNumber);
                printf("Enter value to add: ");
                scanf("%d", &value);
                if (queueNumber == 1) {
                    addq1(&q, value);
                } else if (queueNumber == 2) {
                    addq2(&q, value);
                } else {
                    printf("Invalid queue number\n");
                }
                break;
            case 2:
                printf("Enter queue number (1 or 2): ");
                scanf("%d", &queueNumber);
                if (queueNumber == 1) {
                    printf("Deleted from Queue1: %d\n", delq1(&q));
                } else if (queueNumber == 2) {
                    printf("Deleted from Queue2: %d\n", delq2(&q));
                } else {
                    printf("Invalid queue number\n");
                }
                break;
            case 3:
                printf("Enter queue number (1 or 2) to display: ");
                scanf("%d", &queueNumber);
                if (queueNumber == 1) {
                    displayQueue1(&q);
                } else if (queueNumber == 2) {
                    displayQueue2(&q);
                } else {
                    printf("Invalid queue number\n");
                }
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice\n");
        }
    }

    return 0;
}





8.Write an iterative Reverse() function that reverses a list by rearranging all the next pointers and the head pointer. Ideally, Reverse() should only need to make one pass of the list.
#include <stdio.h>
#include <stdlib.h>

// Definition of the singly linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to reverse the linked list iteratively
void Reverse(struct Node** head) {
    struct Node* prev = NULL;
    struct Node* current = *head;
    struct Node* next = NULL;
    while (current != NULL) {
        // Store the next node
        next = current->next;
        // Reverse the current node's pointer
        current->next = prev;
        // Move pointers one position ahead
        prev = current;
        current = next;
    }
    // Update head to the new first node
    *head = prev;
}

// Function to print the linked list
void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Function to insert a node at the end of the list
void insertAtEnd(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    struct Node* temp = *head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
}

// Main function to demonstrate the reverse operation
int main() {
    struct Node* head = NULL;
    int n, data;

    // Taking the number of nodes as input
    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    // Taking the data for each node as input
    for (int i = 0; i < n; i++) {
        printf("Enter data for node %d: ", i + 1);
        scanf("%d", &data);
        insertAtEnd(&head, data);
    }

    printf("Original List: ");
    printList(head);

    // Reverse the linked list
    Reverse(&head);

    printf("Reversed List: ");
    printList(head);

    return 0;
}
 




13.Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Preorder Traversal b. Count Leaf Nodes c. Count total no. of nodes d. Display height of a tree.

#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert nodes in level order
struct Node* insertLevelOrder(int arr[], int n) {
    struct Node** nodes = (struct Node*)malloc(n * sizeof(struct Node));
    struct Node* root = createNode(arr[0]);
    nodes[0] = root;
    for (int i = 1; i < n; i++) {
        struct Node* newNode = createNode(arr[i]);
        nodes[i] = newNode;
        if (i % 2 == 1) {
            nodes[(i - 1) / 2]->left = newNode;
        } else {
            nodes[(i - 2) / 2]->right = newNode;
        }
    }
    free(nodes);
    return root;
}

// Function to perform preorder traversal non-recursively
void preorderTraversal(struct Node* root) {
    if (root == NULL) return;

    struct Node* stack[100];
    int top = -1;
    stack[++top] = root;

    while (top >= 0) {
        struct Node* node = stack[top--];
        printf("%d ", node->data);

        if (node->right) {
            stack[++top] = node->right;
        }
        if (node->left) {
            stack[++top] = node->left;
        }
    }
}

// Function to count leaf nodes non-recursively
int countLeafNodes(struct Node* root) {
    if (root == NULL) return 0;

    struct Node* stack[100];
    int top = -1;
    stack[++top] = root;
    int leafCount = 0;

    while (top >= 0) {
        struct Node* node = stack[top--];

        if (node->left == NULL && node->right == NULL) {
            leafCount++;
        }

        if (node->right) {
            stack[++top] = node->right;
        }
        if (node->left) {
            stack[++top] = node->left;
        }
    }
    return leafCount;
}

// Function to count total number of nodes non-recursively
int countTotalNodes(struct Node* root) {
    if (root == NULL) return 0;

    struct Node* stack[100];
    int top = -1;
    stack[++top] = root;
    int nodeCount = 0;

    while (top >= 0) {
        struct Node* node = stack[top--];
        nodeCount++;

        if (node->right) {
            stack[++top] = node->right;
        }
        if (node->left) {
            stack[++top] = node->left;
        }
    }
    return nodeCount;
}

// Function to find height of the tree non-recursively
int heightOfTree(struct Node* root) {
    if (root == NULL) return 0;

    struct Node* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;
    int height = 0;

    while (front < rear) {
        int nodeCount = rear - front;
        height++;
        
        while (nodeCount > 0) {
            struct Node* node = queue[front++];
            if (node->left) queue[rear++] = node->left;
            if (node->right) queue[rear++] = node->right;
            nodeCount--;
        }
    }
    return height;
}

// Main function to demonstrate the operations
int main() {
    int n;
    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    int arr[n];
    printf("Enter the elements of the tree: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    struct Node* root = insertLevelOrder(arr, n);

    printf("Preorder Traversal: ");
    preorderTraversal(root);
    printf("\n");

    int leafNodes = countLeafNodes(root);
    printf("Number of leaf nodes: %d\n", leafNodes);

    int totalNodes = countTotalNodes(root);
    printf("Total number of nodes: %d\n", totalNodes);

    int height = heightOfTree(root);
    printf("Height of the tree: %d\n", height);

    return 0;
}

        

14.Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Inorder Traversal b. Mirror Image c. Count total no. of nodes d. Display height of a tree.

#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert nodes in level order
struct Node* insertLevelOrder(int arr[], int n) {
    if (n == 0) return NULL;

    struct Node** nodes = (struct Node*)malloc(n * sizeof(struct Node));
    struct Node* root = createNode(arr[0]);
    nodes[0] = root;
    for (int i = 1; i < n; i++) {
        struct Node* newNode = createNode(arr[i]);
        nodes[i] = newNode;
        if (i % 2 == 1) {
            nodes[(i - 1) / 2]->left = newNode;
        } else {
            nodes[(i - 2) / 2]->right = newNode;
        }
    }
    free(nodes);
    return root;
}

// Function to perform inorder traversal non-recursively
void inorderTraversal(struct Node* root) {
    if (root == NULL) return;

    struct Node* stack[100];
    int top = -1;
    struct Node* current = root;

    while (current != NULL || top >= 0) {
        while (current != NULL) {
            stack[++top] = current;
            current = current->left;
        }
        current = stack[top--];
        printf("%d ", current->data);
        current = current->right;
    }
}

// Function to create mirror image of a binary tree non-recursively
void mirrorTree(struct Node* root) {
    if (root == NULL) return;

    struct Node* stack[100];
    int top = -1;
    stack[++top] = root;

    while (top >= 0) {
        struct Node* node = stack[top--];

        // Swap left and right children
        struct Node* temp = node->left;
        node->left = node->right;
        node->right = temp;

        if (node->left) {
            stack[++top] = node->left;
        }
        if (node->right) {
            stack[++top] = node->right;
        }
    }
}

// Function to count total number of nodes non-recursively
int countTotalNodes(struct Node* root) {
    if (root == NULL) return 0;

    struct Node* stack[100];
    int top = -1;
    stack[++top] = root;
    int nodeCount = 0;

    while (top >= 0) {
        struct Node* node = stack[top--];
        nodeCount++;

        if (node->right) {
            stack[++top] = node->right;
        }
        if (node->left) {
            stack[++top] = node->left;
        }
    }
    return nodeCount;
}

// Function to find height of the tree non-recursively
int heightOfTree(struct Node* root) {
    if (root == NULL) return 0;

    struct Node* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;
    int height = 0;

    while (front < rear) {
        int nodeCount = rear - front;
        height++;
        
        while (nodeCount > 0) {
            struct Node* node = queue[front++];
            if (node->left) queue[rear++] = node->left;
            if (node->right) queue[rear++] = node->right;
            nodeCount--;
        }
    }
    return height;
}

// Main function to demonstrate the operations
int main() {
    int n;
    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    int arr[n];
    printf("Enter the elements of the tree: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    struct Node* root = insertLevelOrder(arr, n);

    printf("Inorder Traversal: ");
    inorderTraversal(root);
    printf("\n");

    mirrorTree(root);
    printf("Inorder Traversal after Mirroring: ");
    inorderTraversal(root);
    printf("\n");

    int totalNodes = countTotalNodes(root);
    printf("Total number of nodes: %d\n", totalNodes);

    int height = heightOfTree(root);
    printf("Height of the tree: %d\n", height);

    return 0;
}
 

15.Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Postorder Traversal b. Display Leaf Nodes c. Count total no. of  Leaf nodes d. Display height of a tree.

#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert nodes in level order
struct Node* insertLevelOrder(int arr[], int n) {
    if (n == 0) return NULL;

    struct Node** nodes = (struct Node*)malloc(n * sizeof(struct Node));
    struct Node* root = createNode(arr[0]);
    nodes[0] = root;
    for (int i = 1; i < n; i++) {
        struct Node* newNode = createNode(arr[i]);
        nodes[i] = newNode;
        if (i % 2 == 1) {
            nodes[(i - 1) / 2]->left = newNode;
        } else {
            nodes[(i - 2) / 2]->right = newNode;
        }
    }
    free(nodes);
    return root;
}

// Function to perform postorder traversal non-recursively
void postorderTraversal(struct Node* root) {
    if (root == NULL) return;

    struct Node* stack1[100];
    struct Node* stack2[100];
    int top1 = -1, top2 = -1;

    stack1[++top1] = root;
    while (top1 >= 0) {
        struct Node* node = stack1[top1--];
        stack2[++top2] = node;
        if (node->left) {
            stack1[++top1] = node->left;
        }
        if (node->right) {
            stack1[++top1] = node->right;
        }
    }

    while (top2 >= 0) {
        printf("%d ", stack2[top2--]->data);
    }
}

// Function to display leaf nodes non-recursively
void displayLeafNodes(struct Node* root) {
    if (root == NULL) return;

    struct Node* stack[100];
    int top = -1;
    stack[++top] = root;

    while (top >= 0) {
        struct Node* node = stack[top--];

        if (node->left == NULL && node->right == NULL) {
            printf("%d ", node->data);
        }

        if (node->right) {
            stack[++top] = node->right;
        }
        if (node->left) {
            stack[++top] = node->left;
        }
    }
}

// Function to count total number of leaf nodes non-recursively
int countLeafNodes(struct Node* root) {
    if (root == NULL) return 0;

    struct Node* stack[100];
    int top = -1;
    stack[++top] = root;
    int leafCount = 0;

    while (top >= 0) {
        struct Node* node = stack[top--];

        if (node->left == NULL && node->right == NULL) {
            leafCount++;
        }

        if (node->right) {
            stack[++top] = node->right;
        }
        if (node->left) {
            stack[++top] = node->left;
        }
    }
    return leafCount;
}

// Function to find height of the tree non-recursively
int heightOfTree(struct Node* root) {
    if (root == NULL) return 0;

    struct Node* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;
    int height = 0;

    while (front < rear) {
        int nodeCount = rear - front;
        height++;
        
        while (nodeCount > 0) {
            struct Node* node = queue[front++];
            if (node->left) queue[rear++] = node->left;
            if (node->right) queue[rear++] = node->right;
            nodeCount--;
        }
    }
    return height;
}

// Main function to demonstrate the operations
int main() {
    int n;
    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    int arr[n];
    printf("Enter the elements of the tree: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    struct Node* root = insertLevelOrder(arr, n);

    printf("Postorder Traversal: ");
    postorderTraversal(root);
    printf("\n");

    printf("Leaf Nodes: ");
    displayLeafNodes(root);
    printf("\n");

    int leafNodes = countLeafNodes(root);
    printf("Total number of leaf nodes: %d\n", leafNodes);

    int height = heightOfTree(root);
    printf("Height of the tree: %d\n", height);

    return 0;
}
 

16.Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Level-wise Traversal b. Display Leaf Nodes c. Count total no. of Leaf nodes d. Display height of a tree.

#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert nodes in level order
struct Node* insertLevelOrder(int arr[], int n) {
    if (n == 0) return NULL;

    struct Node** nodes = (struct Node*)malloc(n * sizeof(struct Node));
    struct Node* root = createNode(arr[0]);
    nodes[0] = root;
    for (int i = 1; i < n; i++) {
        struct Node* newNode = createNode(arr[i]);
        nodes[i] = newNode;
        if (i % 2 == 1) {
            nodes[(i - 1) / 2]->left = newNode;
        } else {
            nodes[(i - 2) / 2]->right = newNode;
        }
    }
    free(nodes);
    return root;
}

// Function to perform level-wise traversal non-recursively
void levelWiseTraversal(struct Node* root) {
    if (root == NULL) return;

    struct Node* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (front < rear) {
        struct Node* node = queue[front++];
        printf("%d ", node->data);

        if (node->left) {
            queue[rear++] = node->left;
        }
        if (node->right) {
            queue[rear++] = node->right;
        }
    }
}

// Function to display leaf nodes non-recursively
void displayLeafNodes(struct Node* root) {
    if (root == NULL) return;

    struct Node* stack[100];
    int top = -1;
    stack[++top] = root;

    while (top >= 0) {
        struct Node* node = stack[top--];

        if (node->left == NULL && node->right == NULL) {
            printf("%d ", node->data);
        }

        if (node->right) {
            stack[++top] = node->right;
        }
        if (node->left) {
            stack[++top] = node->left;
        }
    }
}

// Function to count total number of leaf nodes non-recursively
int countLeafNodes(struct Node* root) {
    if (root == NULL) return 0;

    struct Node* stack[100];
    int top = -1;
    stack[++top] = root;
    int leafCount = 0;

    while (top >= 0) {
        struct Node* node = stack[top--];

        if (node->left == NULL && node->right == NULL) {
            leafCount++;
        }

        if (node->right) {
            stack[++top] = node->right;
        }
        if (node->left) {
            stack[++top] = node->left;
        }
    }
    return leafCount;
}

// Function to find height of the tree non-recursively
int heightOfTree(struct Node* root) {
    if (root == NULL) return 0;

    struct Node* queue[100];
    int height = 0;
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (1) {
        int nodeCount = rear - front;
        if (nodeCount == 0) return height;

        height++;
        while (nodeCount > 0) {
            struct Node* node = queue[front++];
            if (node->left) queue[rear++] = node->left;
            if (node->right) queue[rear++] = node->right;
            nodeCount--;
        }
    }
}

// Main function to demonstrate the operations
int main() {
    int n;
    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    int arr[n];
    printf("Enter the elements of the tree: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    struct Node* root = insertLevelOrder(arr, n);

    printf("Level-wise Traversal: ");
    levelWiseTraversal(root);
    printf("\n");

    printf("Leaf Nodes: ");
    displayLeafNodes(root);
    printf("\n");

    int leafNodes = countLeafNodes(root);
    printf("Total number of leaf nodes: %d\n", leafNodes);

    int height = heightOfTree(root);
    printf("Height of the tree: %d\n", height);

    return 0;
}
 

17. Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Levelwise display b. Mirror image c. Display height of a tree.
#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert nodes in level order
struct Node* insertLevelOrder(int arr[], int n) {
    if (n == 0) return NULL;

    struct Node** nodes = (struct Node*)malloc(n * sizeof(struct Node));
    struct Node* root = createNode(arr[0]);
    nodes[0] = root;
    for (int i = 1; i < n; i++) {
        struct Node* newNode = createNode(arr[i]);
        nodes[i] = newNode;
        if (i % 2 == 1) {
            nodes[(i - 1) / 2]->left = newNode;
        } else {
            nodes[(i - 2) / 2]->right = newNode;
        }
    }
    free(nodes);
    return root;
}

// Function to perform level-wise traversal non-recursively
void levelWiseTraversal(struct Node* root) {
    if (root == NULL) return;

    struct Node* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (front < rear) {
        struct Node* node = queue[front++];
        printf("%d ", node->data);

        if (node->left) {
            queue[rear++] = node->left;
        }
        if (node->right) {
            queue[rear++] = node->right;
        }
    }
}

// Function to create mirror image of the tree
void mirror(struct Node* root) {
    if (root == NULL) return;

    struct Node* temp;

    // Recursively call mirror for left and right subtrees
    mirror(root->left);
    mirror(root->right);

    // Swap left and right children
    temp = root->left;
    root->left = root->right;
    root->right = temp;
}

// Function to find height of the tree non-recursively
int heightOfTree(struct Node* root) {
    if (root == NULL) return 0;

    struct Node* queue[100];
    int height = 0;
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (1) {
        int nodeCount = rear - front;
        if (nodeCount == 0) return height;

        height++;
        while (nodeCount > 0) {
            struct Node* node = queue[front++];
            if (node->left) queue[rear++] = node->left;
            if (node->right) queue[rear++] = node->right;
            nodeCount--;
        }
    }
}

// Main function to demonstrate the operations
int main() {
    int n;
    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    int arr[n];
    printf("Enter the elements of the tree: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    struct Node* root = insertLevelOrder(arr, n);

    printf("Level-wise Traversal: ");
    levelWiseTraversal(root);
    printf("\n");

    // Create the mirror image of the tree
    mirror(root);

    printf("Level-wise Traversal of Mirror Image: ");
    levelWiseTraversal(root);
    printf("\n");

    int height = heightOfTree(root);
    printf("Height of the tree: %d\n", height);

    return 0;
}

18. Write a program to illustrate operations on a BST holding numeric keys. The menu must include: • Insert • Delete • Find • Level wise Display
#include <stdio.h>
#include <stdlib.h>

// Definition of the node structure
struct Node {
    int key;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a key into the BST
struct Node* insert(struct Node* node, int key) {
    if (node == NULL)
        return createNode(key);

    if (key < node->key)
        node->left = insert(node->left, key);
    else if (key > node->key)
        node->right = insert(node->right, key);

    return node;
}

// Function to find the minimum value node in a tree
struct Node* minValueNode(struct Node* node) {
    struct Node* current = node;
    while (current && current->left != NULL)
        current = current->left;
    return current;
}

// Function to delete a node from the BST
struct Node* deleteNode(struct Node* root, int key) {
    if (root == NULL)
        return root;

    if (key < root->key)
        root->left = deleteNode(root->left, key);
    else if (key > root->key)
        root->right = deleteNode(root->right, key);
    else {
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }

        struct Node* temp = minValueNode(root->right);
        root->key = temp->key;
        root->right = deleteNode(root->right, temp->key);
    }
    return root;
}

// Function to find a key in the BST
struct Node* find(struct Node* node, int key) {
    if (node == NULL || node->key == key)
        return node;

    if (key < node->key)
        return find(node->left, key);
    else
        return find(node->right, key);
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Insert\n");
    printf("2. Delete\n");
    printf("3. Find\n");
    printf("4. Level-wise display\n");
    printf("5. Exit\n");
    printf("Enter your choice: ");
}

// Function to perform level-wise traversal of the BST
void levelWiseTraversal(struct Node* root) {
    if (root == NULL)
        return;

    struct Node* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (front < rear) {
        struct Node* node = queue[front++];
        printf("%d ", node->key);

        if (node->left != NULL)
            queue[rear++] = node->left;
        if (node->right != NULL)
            queue[rear++] = node->right;
    }
    printf("\n");
}

int main() {
    struct Node* root = NULL;
    int choice, key, numElements;

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the number of elements to insert: ");
                scanf("%d", &numElements);
                printf("Enter %d keys to insert:\n", numElements);
                for (int i = 0; i < numElements; i++) {
                    scanf("%d", &key);
                    root = insert(root, key);
                }
                break;
            case 2:
                printf("Enter key to delete: ");
                scanf("%d", &key);
                root = deleteNode(root, key);
                break;
            case 3:
                printf("Enter key to find: ");
                scanf("%d", &key);
                if (find(root, key) != NULL)
                    printf("Key %d found in the tree.\n", key);
                else
                    printf("Key %d not found in the tree.\n", key);
                break;
            case 4:
                printf("Level-wise display of the tree:\n");
                levelWiseTraversal(root);
                break;
            case 5:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}



19.Write a program to illustrate operations on a BST holding numeric keys. The menu must include: • Insert • Mirror Image • Find • Height of the tree

#include <stdio.h>
#include <stdlib.h>

// Definition of the node structure
struct Node {
    int key;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int key) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a key into the BST
struct Node* insert(struct Node* node, int key) {
    if (node == NULL)
        return createNode(key);

    if (key < node->key)
        node->left = insert(node->left, key);
    else if (key > node->key)
        node->right = insert(node->right, key);

    return node;
}

// Function to create the mirror image of the BST
void mirror(struct Node* node) {
    if (node == NULL)
        return;

    struct Node* temp = node->left;
    node->left = node->right;
    node->right = temp;

    mirror(node->left);
    mirror(node->right);
}

// Function to find a key in the BST
struct Node* find(struct Node* node, int key) {
    if (node == NULL || node->key == key)
        return node;

    if (key < node->key)
        return find(node->left, key);
    else
        return find(node->right, key);
}

// Function to get the height of the BST
int height(struct Node* node) {
    if (node == NULL)
        return 0;
    else {
        int leftHeight = height(node->left);
        int rightHeight = height(node->right);
        return (leftHeight > rightHeight) ? (leftHeight + 1) : (rightHeight + 1);
    }
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Insert\n");
    printf("2. Mirror Image\n");
    printf("3. Find\n");
    printf("4. Height of the tree\n");
    printf("5. Exit\n");
    printf("Enter your choice: ");
}

// Function to perform in-order traversal of the BST
void inOrderTraversal(struct Node* root) {
    if (root != NULL) {
        inOrderTraversal(root->left);
        printf("%d ", root->key);
        inOrderTraversal(root->right);
    }
}

int main() {
    struct Node* root = NULL;
    int choice, key, numElements;

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the number of elements to insert: ");
                scanf("%d", &numElements);
                printf("Enter %d keys to insert:\n", numElements);
                for (int i = 0; i < numElements; i++) {
                    scanf("%d", &key);
                    root = insert(root, key);
                }
                break;
            case 2:
                mirror(root);
                printf("Mirror image of the tree:\n");
                inOrderTraversal(root);
                printf("\n");
                mirror(root); // Restore the original tree
                break;
            case 3:
                printf("Enter key to find: ");
                scanf("%d", &key);
                if (find(root, key) != NULL)
                    printf("Key %d found in the tree.\n", key);
                else
                    printf("Key %d not found in the tree.\n", key);
                break;
            case 4:
                printf("Height of the tree: %d\n", height(root));
                break;
            case 5:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}

 
 
 
 


20.Write a Program to create a Binary Tree and perform following Non-recursive operations on it. a. Postorder Traversal  c. Display Leaf Nodes d. Mirror Image
#include <stdio.h>
#include <stdlib.h>

// Structure of a binary tree node
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// Structure of a stack node (used for non-recursive traversal)
struct StackNode {
    struct TreeNode* treeNode;
    struct StackNode* next;
};

// Function to create a new tree node
struct TreeNode* createNode(int data) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to push a tree node onto the stack
void push(struct StackNode** top, struct TreeNode* treeNode) {
    struct StackNode* newNode = (struct StackNode*)malloc(sizeof(struct StackNode));
    newNode->treeNode = treeNode;
    newNode->next = *top;
    *top = newNode;
}

// Function to pop a tree node from the stack
struct TreeNode* pop(struct StackNode** top) {
    if (*top == NULL)
        return NULL;
    struct TreeNode* poppedNode = (*top)->treeNode;
    struct StackNode* temp = *top;
    *top = (*top)->next;
    free(temp);
    return poppedNode;
}

// Function to perform postorder traversal iteratively
void postOrderTraversal(struct TreeNode* root) {
    if (root == NULL)
        return;

    struct StackNode* stack = NULL;
    struct TreeNode* currNode = root;
    struct TreeNode* lastVisited = NULL;

    while (currNode || stack) {
        if (currNode) {
            push(&stack, currNode);
            currNode = currNode->left;
        } else {
            struct TreeNode* peekNode = stack->treeNode;
            if (peekNode->right && lastVisited != peekNode->right) {
                currNode = peekNode->right;
            } else {
                printf("%d ", peekNode->data);
                lastVisited = pop(&stack);
            }
        }
    }
}

// Function to display leaf nodes of the tree
void displayLeafNodes(struct TreeNode* root) {
    if (root == NULL)
        return;

    struct StackNode* stack = NULL;
    struct TreeNode* currNode = root;

    while (currNode || stack) {
        if (currNode) {
            push(&stack, currNode);
            currNode = currNode->left;
        } else {
            struct TreeNode* peekNode = stack->treeNode;
            if (peekNode->right == NULL && peekNode->left == NULL) {
                printf("%d ", peekNode->data);
            }
            pop(&stack);
            currNode = peekNode->right;
        }
    }
}

// Function to create the mirror image of the tree
void mirrorImage(struct TreeNode* root) {
    if (root == NULL)
        return;

    // Recursively mirror the left and right subtrees
    mirrorImage(root->left);
    mirrorImage(root->right);

    // Swap left and right children of current node
    struct TreeNode* temp = root->left;
    root->left = root->right;
    root->right = temp;
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Postorder Traversal\n");
    printf("2. Display Leaf Nodes\n");
    printf("3. Mirror Image\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct TreeNode* root = NULL;
    int choice, numElements, data;

    // Input number of elements and their values
    printf("Enter the number of elements to insert: ");
    scanf("%d", &numElements);
    printf("Enter %d elements to create the binary tree:\n", numElements);
    for (int i = 0; i < numElements; i++) {
        scanf("%d", &data);
        if (root == NULL) {
            root = createNode(data);
        } else {
            struct TreeNode* currentNode = root;
            while (1) {
                if (data <= currentNode->data) {
                    if (currentNode->left == NULL) {
                        currentNode->left = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->left;
                    }
                } else {
                    if (currentNode->right == NULL) {
                        currentNode->right = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->right;
                    }
                }
            }
        }
    }

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Postorder Traversal: ");
                postOrderTraversal(root);
                printf("\n");
                break;
            case 2:
                printf("Leaf Nodes: ");
                displayLeafNodes(root);
                printf("\n");
                break;
            case 3:
                printf("Mirror Image:\n");
                mirrorImage(root);
                postOrderTraversal(root);
                printf("\n");
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}

 
 

21.Write a Program to create a Binary Search Tree and perform following non-recursive operations on it. a. Inorder Traversal b. Display Number of Leaf Nodes c. Mirror Image
#include <stdio.h>
#include <stdlib.h>

// Structure of a binary tree node
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// Structure of a stack node (used for non-recursive traversal)
struct StackNode {
    struct TreeNode* treeNode;
    struct StackNode* next;
};

// Function to create a new tree node
struct TreeNode* createNode(int data) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to push a tree node onto the stack
void push(struct StackNode** top, struct TreeNode* treeNode) {
    struct StackNode* newNode = (struct StackNode*)malloc(sizeof(struct StackNode));
    newNode->treeNode = treeNode;
    newNode->next = *top;
    *top = newNode;
}

// Function to pop a tree node from the stack
struct TreeNode* pop(struct StackNode** top) {
    if (*top == NULL)
        return NULL;
    struct TreeNode* poppedNode = (*top)->treeNode;
    struct StackNode* temp = *top;
    *top = (*top)->next;
    free(temp);
    return poppedNode;
}

// Function to perform inorder traversal iteratively
void inOrderTraversal(struct TreeNode* root) {
    if (root == NULL)
        return;

    struct StackNode* stack = NULL;
    struct TreeNode* currNode = root;

    while (currNode || stack) {
        while (currNode) {
            push(&stack, currNode);
            currNode = currNode->left;
        }
        currNode = pop(&stack);
        printf("%d ", currNode->data);
        currNode = currNode->right;
    }
}

// Function to count the number of leaf nodes in the tree
int countLeafNodes(struct TreeNode* root) {
    if (root == NULL)
        return 0;

    int leafCount = 0;
    struct StackNode* stack = NULL;
    struct TreeNode* currNode = root;

    while (currNode || stack) {
        while (currNode) {
            push(&stack, currNode);
            currNode = currNode->left;
        }
        currNode = pop(&stack);
        if (currNode->left == NULL && currNode->right == NULL)
            leafCount++;
        currNode = currNode->right;
    }

    return leafCount;
}

// Function to create the mirror image of the tree
void mirrorImage(struct TreeNode* root) {
    if (root == NULL)
        return;

    // Iteratively mirror the left and right subtrees using stack
    struct StackNode* stack = NULL;
    push(&stack, root);

    while (stack) {
        struct TreeNode* currNode = pop(&stack);
        // Swap left and right children of the current node
        struct TreeNode* temp = currNode->left;
        currNode->left = currNode->right;
        currNode->right = temp;

        if (currNode->left)
            push(&stack, currNode->left);
        if (currNode->right)
            push(&stack, currNode->right);
    }
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Inorder Traversal\n");
    printf("2. Display Number of Leaf Nodes\n");
    printf("3. Mirror Image\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct TreeNode* root = NULL;
    int choice, numElements, data;

    // Input number of elements
    printf("Enter the number of elements to insert: ");
    scanf("%d", &numElements);

    // Input values to create the binary tree
    printf("Enter the elements to create the Binary Search Tree:\n");
    for (int i = 0; i < numElements; i++) {
        scanf("%d", &data);
        if (root == NULL) {
            root = createNode(data);
        } else {
            struct TreeNode* currentNode = root;
            while (1) {
                if (data < currentNode->data) {
                    if (currentNode->left == NULL) {
                        currentNode->left = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->left;
                    }
                } else {
                    if (currentNode->right == NULL) {
                        currentNode->right = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->right;
                    }
                }
            }
        }
    }

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Inorder Traversal: ");
                inOrderTraversal(root);
                printf("\n");
                break;
            case 2:
                printf("Number of Leaf Nodes: %d\n", countLeafNodes(root));
                break;
            case 3:
                printf("Mirror Image created.\n");
                mirrorImage(root);
                inOrderTraversal(root);
                printf("\n");
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}
 
 
 

22.Write a Program to create a Binary Search Tree and perform following non-recursive operations on it. a. Preorder Traversal b. Display total Number of Nodes C. Display Leaf nodes.
#include <stdio.h>
#include <stdlib.h>

// Structure of a binary tree node
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// Structure of a stack node (used for non-recursive traversal)
struct StackNode {
    struct TreeNode* treeNode;
    struct StackNode* next;
};

// Function to create a new tree node
struct TreeNode* createNode(int data) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to push a tree node onto the stack
void push(struct StackNode** top, struct TreeNode* treeNode) {
    struct StackNode* newNode = (struct StackNode*)malloc(sizeof(struct StackNode));
    newNode->treeNode = treeNode;
    newNode->next = *top;
    *top = newNode;
}

// Function to pop a tree node from the stack
struct TreeNode* pop(struct StackNode** top) {
    if (*top == NULL)
        return NULL;
    struct TreeNode* poppedNode = (*top)->treeNode;
    struct StackNode* temp = *top;
    *top = (*top)->next;
    free(temp);
    return poppedNode;
}

// Function to perform preorder traversal iteratively
void preOrderTraversal(struct TreeNode* root) {
    if (root == NULL)
        return;

    struct StackNode* stack = NULL;
    push(&stack, root);

    while (stack) {
        struct TreeNode* currNode = pop(&stack);
        printf("%d ", currNode->data);

        if (currNode->right)
            push(&stack, currNode->right);
        if (currNode->left)
            push(&stack, currNode->left);
    }
}

// Function to count the number of leaf nodes in the tree
int countLeafNodes(struct TreeNode* root) {
    if (root == NULL)
        return 0;

    int leafCount = 0;
    struct StackNode* stack = NULL;
    struct TreeNode* currNode = root;

    while (currNode || stack) {
        while (currNode) {
            push(&stack, currNode);
            currNode = currNode->left;
        }
        currNode = pop(&stack);
        if (currNode->left == NULL && currNode->right == NULL)
            leafCount++;
        currNode = currNode->right;
    }

    return leafCount;
}

// Function to create the mirror image of the tree
void mirrorImage(struct TreeNode* root) {
    if (root == NULL)
        return;

    // Iteratively mirror the left and right subtrees using stack
    struct StackNode* stack = NULL;
    push(&stack, root);

    while (stack) {
        struct TreeNode* currNode = pop(&stack);
        // Swap left and right children of the current node
        struct TreeNode* temp = currNode->left;
        currNode->left = currNode->right;
        currNode->right = temp;

        if (currNode->left)
            push(&stack, currNode->left);
        if (currNode->right)
            push(&stack, currNode->right);
    }
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Preorder Traversal\n");
    printf("2. Display Number of Leaf Nodes\n");
    printf("3. Mirror Image\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct TreeNode* root = NULL;
    int choice, numElements, data;

    // Input number of elements
    printf("Enter the number of elements to insert: ");
    scanf("%d", &numElements);

    // Input values to create the binary tree
    printf("Enter the elements to create the Binary Search Tree:\n");
    for (int i = 0; i < numElements; i++) {
        scanf("%d", &data);
        if (root == NULL) {
            root = createNode(data);
        } else {
            struct TreeNode* currentNode = root;
            while (1) {
                if (data < currentNode->data) {
                    if (currentNode->left == NULL) {
                        currentNode->left = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->left;
                    }
                } else {
                    if (currentNode->right == NULL) {
                        currentNode->right = createNode(data);
                        break;
                    } else {
                        currentNode = currentNode->right;
                    }
                }
            }
        }
    }

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Preorder Traversal: ");
                preOrderTraversal(root);
                printf("\n");
                break;
            case 2:
                printf("Number of Leaf Nodes: %d\n", countLeafNodes(root));
                break;
            case 3:
                printf("Mirror Image created.\n");
                mirrorImage(root);
                preOrderTraversal(root);
                printf("\n");
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}


 
 
 


23.Write a Program to create a Binary Search Tree and perform deletion of a node from it. Also display the tree in nonrecursive postorder way.
#include <stdio.h>
#include <stdlib.h>

// Structure of a binary tree node
struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

// Structure of a stack node (used for non-recursive traversal)
struct StackNode {
    struct TreeNode* treeNode;
    struct StackNode* next;
};

// Function to create a new tree node
struct TreeNode* createNode(int data) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to push a tree node onto the stack
void push(struct StackNode** top, struct TreeNode* treeNode) {
    struct StackNode* newNode = (struct StackNode*)malloc(sizeof(struct StackNode));
    newNode->treeNode = treeNode;
    newNode->next = *top;
    *top = newNode;
}

// Function to pop a tree node from the stack
struct TreeNode* pop(struct StackNode** top) {
    if (*top == NULL)
        return NULL;
    struct TreeNode* poppedNode = (*top)->treeNode;
    struct StackNode* temp = *top;
    *top = (*top)->next;
    free(temp);
    return poppedNode;
}

// Function to perform postorder traversal iteratively
void postOrderTraversal(struct TreeNode* root) {
    if (root == NULL)
        return;

    struct StackNode* stack1 = NULL;
    struct StackNode* stack2 = NULL;
    push(&stack1, root);

    while (stack1) {
        struct TreeNode* currNode = pop(&stack1);
        push(&stack2, currNode);

        if (currNode->left)
            push(&stack1, currNode->left);
        if (currNode->right)
            push(&stack1, currNode->right);
    }

    while (stack2) {
        printf("%d ", pop(&stack2)->data);
    }
}

// Function to insert a node into the BST
struct TreeNode* insert(struct TreeNode* root, int data) {
    if (root == NULL)
        return createNode(data);

    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);

    return root;
}

// Function to find the minimum value node in a subtree
struct TreeNode* minValueNode(struct TreeNode* node) {
    struct TreeNode* current = node;

    // Find the leftmost leaf node
    while (current && current->left != NULL)
        current = current->left;

    return current;
}

// Function to delete a node from the BST
struct TreeNode* deleteNode(struct TreeNode* root, int key) {
    if (root == NULL)
        return root;

    // If the key to be deleted is smaller than the root's key, then it lies in the left subtree
    if (key < root->data)
        root->left = deleteNode(root->left, key);

    // If the key to be deleted is greater than the root's key, then it lies in the right subtree
    else if (key > root->data)
        root->right = deleteNode(root->right, key);

    // If the key is same as root's key, then this is the node to be deleted
    else {
        // Node with only one child or no child
        if (root->left == NULL) {
            struct TreeNode* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct TreeNode* temp = root->left;
            free(root);
            return temp;
        }

        // Node with two children: Get the inorder successor (smallest in the right subtree)
        struct TreeNode* temp = minValueNode(root->right);

        // Copy the inorder successor's content to this node
        root->data = temp->data;

        // Delete the inorder successor
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Insert Element\n");
    printf("2. Delete Element\n");
    printf("3. Display Postorder Traversal\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct TreeNode* root = NULL;
    int choice, numElements, data, key;

    // Input number of elements
    printf("Enter the number of elements to insert: ");
    scanf("%d", &numElements);

    // Input values to create the binary search tree
    printf("Enter the elements to create the Binary Search Tree:\n");
    for (int i = 0; i < numElements; i++) {
        scanf("%d", &data);
        root = insert(root, data);
    }

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter element to insert: ");
                scanf("%d", &data);
                root = insert(root, data);
                break;
            case 2:
                printf("Enter element to delete: ");
                scanf("%d", &key);
                root = deleteNode(root, key);
                break;
            case 3:
                printf("Postorder Traversal: ");
                postOrderTraversal(root);
                printf("\n");
                break;
            case 4:
                exit (0);
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}
24.Write a Program to create a Binary Search Tree and display it levelwise. Also perform deletion of a node from it.
#include <stdio.h>
#include <stdlib.h>

// Structure for a BST node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new BST node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert a node into the BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL)
        return createNode(data);
    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);
    return root;
}

// Function to perform level-wise traversal of the BST
void levelOrderTraversal(struct Node* root) {
    if (root == NULL)
        return;

    struct Node* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (front < rear) {
        struct Node* current = queue[front++];
        printf("%d ", current->data);

        if (current->left != NULL)
            queue[rear++] = current->left;
        if (current->right != NULL)
            queue[rear++] = current->right;
    }
}

// Function to find the node with minimum value in a BST
struct Node* minValueNode(struct Node* node) {
    struct Node* current = node;
    while (current->left != NULL)
        current = current->left;
    return current;
}

// Function to delete a node from the BST
struct Node* deleteNode(struct Node* root, int key) {
    if (root == NULL)
        return root;
    if (key < root->data)
        root->left = deleteNode(root->left, key);
    else if (key > root->data)
        root->right = deleteNode(root->right, key);
    else {
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }
        struct Node* temp = minValueNode(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Create Binary Search Tree\n");
    printf("2. Display BST Level-wise\n");
    printf("3. Delete a element\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct Node* root = NULL;
    int choice, numNodes, data, key;

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the number of elements: ");
                scanf("%d", &numNodes);
                printf("Enter the elements level-wise:\n");
                for (int i = 0; i < numNodes; i++) {
                    scanf("%d", &data);
                    root = insert(root, data);
                }
                break;
            case 2:
                printf("Level-wise traversal of the BST: ");
                levelOrderTraversal(root);
                printf("\n");
                break;
            case 3:
                printf("Enter the key to delete from the Binary Search Tree: ");
                scanf("%d", &key);
                root = deleteNode(root, key);
                printf("Element with key %d deleted successfully.\n", key);
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}
 
 
 

25.Write a Program to create a Binary Search Tree and display its mirror image with and without disturbing the original tree. Also display height of a tree using nonrecursion.
#include <stdio.h>
#include <stdlib.h>

// Structure for a BST node
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Structure for queue node (used for level order traversal)
struct QueueNode {
    struct Node* treeNode;
    struct QueueNode* next;
};

// Function to create a new BST node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function to insert an element into the BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL)
        return createNode(data);
    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);
    return root;
}

// Function to perform inorder traversal of the BST
void inorderTraversal(struct Node* root) {
    if (root == NULL)
        return;
    inorderTraversal(root->left);
    printf("%d ", root->data);
    inorderTraversal(root->right);
}

// Function to create the mirror image of the BST without disturbing the original tree
struct Node* mirrorImage(struct Node* root) {
    if (root == NULL)
        return NULL;

    struct Node* mirror = createNode(root->data);
    mirror->left = mirrorImage(root->right);
    mirror->right = mirrorImage(root->left);
    return mirror;
}

// Function to create the mirror image of the BST and update the original tree
void mirrorAndUpdate(struct Node* root) {
    if (root == NULL)
        return;

    struct Node* temp = root->left;
    root->left = root->right;
    root->right = temp;

    mirrorAndUpdate(root->left);
    mirrorAndUpdate(root->right);
}
// Function to enqueue a tree node into the queue
void enqueue(struct QueueNode** front, struct Node* treeNode) {
    struct QueueNode* newNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
    newNode->treeNode = treeNode;
    newNode->next = NULL;
    if (*front == NULL) {
        *front = newNode;
    } else {
        struct QueueNode* rear = *front;
        while (rear->next != NULL) {
            rear = rear->next;
        }
        rear->next = newNode;
    }
}

// Function to dequeue a tree node from the queue
struct Node* dequeue(struct QueueNode** front) {
    if (*front == NULL)
        return NULL;
    struct Node* dequeuedNode = (*front)->treeNode;
    struct QueueNode* temp = *front;
    *front = (*front)->next;
    free(temp);
    return dequeuedNode;
}

// Function to calculate the size of the queue
int queueSize(struct QueueNode* front) {
    int size = 0;
    while (front) {
        size++;
        front = front->next;
    }
    return size;
}
// Function to calculate the height of the tree using level order traversal
int heightNonRecursive(struct Node* root) {
    if (root == NULL)
        return 0;

    struct QueueNode* queue = NULL;
    enqueue(&queue, root);
    int height = 0;

    while (queue) {
        int levelSize = queueSize(queue);
        while (levelSize--) {
            struct Node* currNode = dequeue(&queue);
            if (currNode->left)
                enqueue(&queue, currNode->left);
            if (currNode->right)
                enqueue(&queue, currNode->right);
        }
        height++;
    }

    return height;
}
// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Create Binary Search Tree\n");
    printf("2. Display BST\n");
    printf("3. Display Mirror Image without Disturbing Original Tree\n");
    printf("4. Display Mirror Image with Updating Original Tree\n");
    printf("5. Calculate Height of the Tree (Non-Recursive)\n");
    printf("6. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct Node* root = NULL;
    int choice, numElements, data;

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the number of elements: ");
                scanf("%d", &numElements);
                printf("Enter the elements:\n");
                for (int i = 0; i < numElements; i++) {
                    scanf("%d", &data);
                    root = insert(root, data);
                }
                break;
            case 2:
                printf("BST: ");
                inorderTraversal(root);
                printf("\n");
                break;
            case 3:
                printf("Mirror Image without Disturbing Original Tree: ");
                inorderTraversal(mirrorImage(root));
                printf("\n");
                break;
            case 4:
                printf("Mirror Image with Updating Original Tree\n");
                mirrorAndUpdate(root);
                printf("BST: ");
                inorderTraversal(root);
                printf("\n");
                break;
            case 5:
                printf("Height of the Tree (Non-Recursive): %d\n", heightNonRecursive(root));
                break;
            case 6:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}

 
 
 
 
 

26. Write a program to efficiently search a particular employee record by using Tree data structure. Also sort the data on emp-id in ascending order.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Definition of the employee node structure
struct Employee {
    int emp_id;
    char emp_name[100];
    float emp_salary;
    struct Employee* left;
    struct Employee* right;
};

// Function to create a new employee node
struct Employee* createEmployee(int emp_id, char emp_name[], float emp_salary) {
    struct Employee* newEmployee = (struct Employee*)malloc(sizeof(struct Employee));
    newEmployee->emp_id = emp_id;
    strcpy(newEmployee->emp_name, emp_name);
    newEmployee->emp_salary = emp_salary;
    newEmployee->left = newEmployee->right = NULL;
    return newEmployee;
}

// Function to insert a new employee into the BST
struct Employee* insert(struct Employee* node, int emp_id, char emp_name[], float emp_salary) {
    if (node == NULL)
        return createEmployee(emp_id, emp_name, emp_salary);

    if (emp_id < node->emp_id)
        node->left = insert(node->left, emp_id, emp_name, emp_salary);
    else if (emp_id > node->emp_id)
        node->right = insert(node->right, emp_id, emp_name, emp_salary);

    return node;
}

// Function to search for an employee by emp_id
struct Employee* search(struct Employee* root, int emp_id) {
    if (root == NULL || root->emp_id == emp_id)
        return root;

    if (emp_id < root->emp_id)
        return search(root->left, emp_id);
    else
        return search(root->right, emp_id);
}

// Function to perform in-order traversal and display employee records
void inOrderTraversal(struct Employee* root) {
    if (root != NULL) {
        inOrderTraversal(root->left);
        printf("Employee ID: %d, Name: %s, Salary: %.2f\n", root->emp_id, root->emp_name, root->emp_salary);
        inOrderTraversal(root->right);
    }
}

// Function to display the menu
void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Insert Employee\n");
    printf("2. Search Employee\n");
    printf("3. Display Employees in Sorted Order\n");
    printf("4. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    struct Employee* root = NULL;
    int choice, emp_id;
    char emp_name[100];
    float emp_salary;

    while (1) {
        displayMenu();
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter Employee ID: ");
                scanf("%d", &emp_id);
                printf("Enter Employee Name: ");
                scanf("%s", emp_name);
                printf("Enter Employee Salary: ");
                scanf("%f", &emp_salary);
                root = insert(root, emp_id, emp_name, emp_salary);
                break;
            case 2:
                printf("Enter Employee ID to search: ");
                scanf("%d", &emp_id);
                struct Employee* emp = search(root, emp_id);
                if (emp != NULL)
                    printf("Employee found: ID: %d, Name: %s, Salary: %.2f\n", emp->emp_id, emp->emp_name, emp->emp_salary);
                else
                    printf("Employee with ID %d not found.\n", emp_id);
                break;
            case 3:
                printf("Employees in sorted order by ID:\n");
                inOrderTraversal(root);
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}


30. Write a Program to accept a graph from user and represent it with Adjacency Matrix and perform BFS traversals on it.

#include <stdio.h>
#include <stdlib.h>

#define MAX 100

int adjMatrix[MAX][MAX];
int visited[MAX];
int queue[MAX], front = -1, rear = -1;

void createGraph(int vertices, int edges) {
    int i, u, v, weight;

    // Initialize adjacency matrix to 0
    for (i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            adjMatrix[i][j] = 0;
        }
    }

    printf("Enter edges (source, destination, weight):\n");
    for (i = 0; i < edges; i++) {
        printf("Edge %d: ", i + 1);
        scanf("%d %d %d", &u, &v, &weight);
        adjMatrix[u][v] = weight;
        adjMatrix[v][u] = weight;  // For undirected graph
    }
}

void displayAdjacencyMatrix(int vertices) {
    int i, j;
    printf("\nAdjacency Matrix:\n");
    for (i = 0; i < vertices; i++) {
        for (j = 0; j < vertices; j++) {
            printf("%d ", adjMatrix[i][j]);
        }
        printf("\n");
    }
}

void enqueue(int vertex) {
    if (rear == MAX - 1)
        printf("Queue Overflow\n");
    else {
        if (front == -1)
            front = 0;
        queue[++rear] = vertex;
    }
}

int dequeue() {
    int delete_item;
    if (front == -1 || front > rear) {
        printf("Queue Underflow\n");
        exit(1);
    } else {
        delete_item = queue[front++];
        return delete_item;
    }
}

int isEmpty() {
    return (front == -1 || front > rear);
}

void BFS(int startVertex, int vertices) {
    int i;
    for (i = 0; i < vertices; i++) {
        visited[i] = 0;
    }

    enqueue(startVertex);
    visited[startVertex] = 1;

    printf("\nBFS Traversal: ");
    while (!isEmpty()) {
        int currentVertex = dequeue();
        printf("%d ", currentVertex);

        for (i = 0; i < vertices; i++) {
            if (adjMatrix[currentVertex][i] != 0 && !visited[i]) {
                enqueue(i);
                visited[i] = 1;
            }
        }
    }
    printf("\n");
}

int main() {
    int vertices, edges, startVertex;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    createGraph(vertices, edges);

    displayAdjacencyMatrix(vertices);

    printf("Enter the starting vertex for BFS: ");
    scanf("%d", &startVertex);

    BFS(startVertex, vertices);

    return 0;
}


31. Write a Program to accept a graph from user and represent it with Adjacency Lists and perform BFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

#define MAX 100

struct Node {
    int vertex;
    int weight;
    struct Node* next;
};

struct Graph {
    int numVertices;
    struct Node** adjLists;
    int* visited;
};

struct Queue {
    int items[MAX];
    int front;
    int rear;
};

// Function to create a node
struct Node* createNode(int v, int weight) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->vertex = v;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// Function to create a graph
struct Graph* createGraph(int vertices) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = (struct Node*)malloc(vertices * sizeof(struct Node));
    graph->visited = (int*)malloc(vertices * sizeof(int));

    for (int i = 0; i < vertices; i++) {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }

    return graph;
}

// Function to add an edge to the graph
void addEdge(struct Graph* graph, int src, int dest, int weight) {
    // Add edge from src to dest
    struct Node* newNode = createNode(dest, weight);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // Add edge from dest to src (since the graph is undirected)
    newNode = createNode(src, weight);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}

// Function to create a queue
struct Queue* createQueue() {
    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
    q->front = -1;
    q->rear = -1;
    return q;
}

// Check if the queue is empty
int isEmpty(struct Queue* q) {
    if (q->rear == -1)
        return 1;
    else
        return 0;
}

// Add to queue
void enqueue(struct Queue* q, int value) {
    if (q->rear == MAX - 1)
        printf("\nQueue is Full!!");
    else {
        if (q->front == -1)
            q->front = 0;
        q->rear++;
        q->items[q->rear] = value;
    }
}

// Remove from queue
int dequeue(struct Queue* q) {
    int item;
    if (isEmpty(q)) {
        printf("Queue is empty");
        item = -1;
    } else {
        item = q->items[q->front];
        q->front++;
        if (q->front > q->rear) {
            q->front = q->rear = -1;
        }
    }
    return item;
}

// BFS algorithm
void BFS(struct Graph* graph, int startVertex) {
    struct Queue* q = createQueue();

    graph->visited[startVertex] = 1;
    enqueue(q, startVertex);

    while (!isEmpty(q)) {
        int currentVertex = dequeue(q);
        printf("%d ", currentVertex);

        struct Node* temp = graph->adjLists[currentVertex];

        while (temp) {
            int adjVertex = temp->vertex;

            if (graph->visited[adjVertex] == 0) {
                graph->visited[adjVertex] = 1;
                enqueue(q, adjVertex);
            }
            temp = temp->next;
        }
    }
}

// Function to display the adjacency list
void displayGraph(struct Graph* graph) {
    for (int v = 0; v < graph->numVertices; v++) {
        struct Node* temp = graph->adjLists[v];
        printf("\nVertex %d: ", v);
        while (temp) {
            printf(" -> %d (weight %d)", temp->vertex, temp->weight);
            temp = temp->next;
        }
        printf("\n");
    }
}

int main() {
    int vertices, edges, src, dest, weight, startVertex;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    struct Graph* graph = createGraph(vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    printf("Enter edges (source, destination, weight):\n");
    for (int i = 0; i < edges; i++) {
        printf("Edge %d: ", i + 1);
        scanf("%d %d %d", &src, &dest, &weight);
        addEdge(graph, src, dest, weight);
    }

    displayGraph(graph);

    printf("\nEnter the starting vertex for BFS: ");
    scanf("%d", &startVertex);

    printf("BFS Traversal starting from vertex %d:\n", startVertex);
    BFS(graph, startVertex);

    return 0;
}


32. Write a Program to accept a graph from user and represent it with Adjacency Matrix and perform DFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

// Function to perform DFS traversal
void DFS(int** adjMatrix, int* visited, int vertex, int numVertices) {
    printf("%d ", vertex);
    visited[vertex] = 1;

    for (int i = 0; i < numVertices; i++) {
        if (adjMatrix[vertex][i] != 0 && !visited[i]) {
            DFS(adjMatrix, visited, i, numVertices);
        }
    }
}

// Function to display the adjacency matrix
void displayMatrix(int** matrix, int numVertices) {
    printf("Adjacency Matrix:\n");
    for (int i = 0; i < numVertices; i++) {
        for (int j = 0; j < numVertices; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int vertices, edges, src, dest, weight, startVertex;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    // Allocate memory for the adjacency matrix
    int** adjMatrix = (int*)malloc(vertices * sizeof(int));
    for (int i = 0; i < vertices; i++) {
        adjMatrix[i] = (int*)malloc(vertices * sizeof(int));
        for (int j = 0; j < vertices; j++) {
            adjMatrix[i][j] = 0;  // Initialize the matrix with zeros
        }
    }

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    printf("Enter edges (source, destination, weight):\n");
    for (int i = 0; i < edges; i++) {
        printf("Edge %d: ", i + 1);
        scanf("%d %d %d", &src, &dest, &weight);
        adjMatrix[src][dest] = weight;
        adjMatrix[dest][src] = weight;  // Because the graph is undirected
    }

    displayMatrix(adjMatrix, vertices);

    int* visited = (int*)malloc(vertices * sizeof(int));
    for (int i = 0; i < vertices; i++) {
        visited[i] = 0;  // Initialize visited array with zeros
    }

    printf("\nEnter the starting vertex for DFS: ");
    scanf("%d", &startVertex);

    printf("DFS Traversal starting from vertex %d:\n", startVertex);
    DFS(adjMatrix, visited, startVertex, vertices);

    // Free allocated memory
    for (int i = 0; i < vertices; i++) {
        free(adjMatrix[i]);
    }
    free(adjMatrix);
    free(visited);

    return 0;
}

33. Write a Program to accept a graph from user and represent it with Adjacency Lists and perform DFS traversals on it
#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
struct Node {
    int vertex;
    int weight;
    struct Node* next;
};

// Define the structure of a graph
struct Graph {
    int numVertices;
    struct Node** adjLists;
    int* visited;
};

// Function to create a node
struct Node* createNode(int v, int weight) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->vertex = v;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// Function to create a graph
struct Graph* createGraph(int vertices) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = (struct Node*)malloc(vertices * sizeof(struct Node));
    graph->visited = (int*)malloc(vertices * sizeof(int));

    for (int i = 0; i < vertices; i++) {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }

    return graph;
}

// Function to add an edge to the graph
void addEdge(struct Graph* graph, int src, int dest, int weight) {
    // Add edge from src to dest
    struct Node* newNode = createNode(dest, weight);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // Add edge from dest to src (since the graph is undirected)
    newNode = createNode(src, weight);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}

// Function to perform DFS traversal
void DFS(struct Graph* graph, int vertex) {
    struct Node* adjList = graph->adjLists[vertex];
    struct Node* temp = adjList;

    graph->visited[vertex] = 1;
    printf("%d ", vertex);

    while (temp != NULL) {
        int connectedVertex = temp->vertex;

        if (graph->visited[connectedVertex] == 0) {
            DFS(graph, connectedVertex);
        }
        temp = temp->next;
    }
}

// Function to display the adjacency list
void displayGraph(struct Graph* graph) {
    for (int v = 0; v < graph->numVertices; v++) {
        struct Node* temp = graph->adjLists[v];
        printf("\nVertex %d: ", v);
        while (temp) {
            printf(" -> %d (weight %d)", temp->vertex, temp->weight);
            temp = temp->next;
        }
        printf("\n");
    }
}

int main() {
    int vertices, edges, src, dest, weight, startVertex;

    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    struct Graph* graph = createGraph(vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    printf("Enter edges (source, destination, weight):\n");
    for (int i = 0; i < edges; i++) {
        printf("Edge %d: ", i + 1);
        scanf("%d %d %d", &src, &dest, &weight);
        addEdge(graph, src, dest, weight);
    }

    displayGraph(graph);

    printf("\nEnter the starting vertex for DFS: ");
    scanf("%d", &startVertex);

    printf("DFS Traversal starting from vertex %d:\n", startVertex);
    DFS(graph, startVertex);

    return 0;
}


34.Write a Program to implement Prim’s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdbool.h>

struct AdjListNode {
    int dest;
    int weight;
    struct AdjListNode* next;
};

struct AdjList {
    struct AdjListNode* head;
};

struct Graph {
    int V;
    struct AdjList* array;
};

struct AdjListNode* newAdjListNode(int dest, int weight) {
    struct AdjListNode* newNode = (struct AdjListNode*)malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

struct Graph* createGraph(int V) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;

    // Create an array of adjacency lists. Size of array will be V
    graph->array = (struct AdjList*)malloc(V * sizeof(struct AdjList));

    // Initialize each adjacency list as empty by making head as NULL
    for (int i = 0; i < V; ++i)
        graph->array[i].head = NULL;

    return graph;
}

void addEdge(struct Graph* graph, int src, int dest, int weight) {
    struct AdjListNode* newNode = newAdjListNode(dest, weight);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;

    newNode = newAdjListNode(src, weight);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

int minKey(int key[], bool mstSet[], int V) {
    int min = INT_MAX, min_index;

    for (int v = 0; v < V; v++)
        if (mstSet[v] == false && key[v] < min)
            min = key[v], min_index = v;

    return min_index;
}

void printMST(int parent[], int n, struct AdjList* array) {
    printf("Edge   Weight\n");
    for (int i = 1; i < n; i++) {
        struct AdjListNode* pCrawl = array[i].head;
        while (pCrawl != NULL) {
            if (pCrawl->dest == parent[i]) {
                printf("%d - %d    %d \n", parent[i], i, pCrawl->weight);
                break;
            }
            pCrawl = pCrawl->next;
        }
    }
}

void primMST(struct Graph* graph) {
    int V = graph->V;
    int parent[V];
    int key[V];
    bool mstSet[V];

    for (int i = 0; i < V; i++)
        key[i] = INT_MAX, mstSet[i] = false;

    key[0] = 0;
    parent[0] = -1;

    for (int count = 0; count < V - 1; count++) {
        int u = minKey(key, mstSet, V);

        mstSet[u] = true;
        struct AdjListNode* pCrawl = graph->array[u].head;
        while (pCrawl != NULL) {
            int v = pCrawl->dest;
            int weight = pCrawl->weight;

            if (mstSet[v] == false && weight < key[v])
                parent[v] = u, key[v] = weight;

            pCrawl = pCrawl->next;
        }
    }

    // Print the constructed MST
    printMST(parent, V, graph->array);
}

int main() {
    int choice, V, E, src, dest, weight;
    
    printf("Enter the number of vertices: ");
    scanf("%d", &V);

    struct Graph* graph = createGraph(V);

    printf("Enter the number of edges: ");
    scanf("%d", &E);

    printf("Enter source, destination and weight for each edge:\n");
    for (int i = 0; i < E; ++i) {
        scanf("%d %d %d", &src, &dest, &weight);
        addEdge(graph, src, dest, weight);
    }

    printf("Minimum Spanning Tree using Prim's Algorithm:\n");
    primMST(graph);

    return 0;
}

 

35.Write a Program to implement Kruskals’s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency Matrix to represent a graph.
#include <stdio.h>
#include <stdlib.h>

// Structure to represent an edge
struct Edge {
    int src, dest, weight;
};

// Structure to represent a graph
struct Graph {
    int V, E;
    struct Edge* edge;
};

// Structure to represent a subset for Union-Find
struct subset {
    int parent;
    int rank;
};

// Function to create a graph with V vertices and E edges
struct Graph* createGraph(int V, int E) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;
    graph->E = E;
    graph->edge = (struct Edge*)malloc(E * sizeof(struct Edge));
    return graph;
}

// Function to find the root of a given vertex
int find(struct subset subsets[], int i) {
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);
    return subsets[i].parent;
}

// Function to perform union of two subsets
void Union(struct subset subsets[], int x, int y) {
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);

    if (subsets[xroot].rank < subsets[yroot].rank)
        subsets[xroot].parent = yroot;
    else if (subsets[xroot].rank > subsets[yroot].rank)
        subsets[yroot].parent = xroot;
    else {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}

// Function to compare two edges based on their weights
int compare(const void* a, const void* b) {
    struct Edge* aEdge = (struct Edge*)a;
    struct Edge* bEdge = (struct Edge*)b;
    return aEdge->weight - bEdge->weight;
}

// Function to find the minimum spanning tree using Kruskal's algorithm
void KruskalMST(struct Graph* graph) {
    int V = graph->V;
    struct Edge result[V];
    int e = 0;
    int i = 0;

    // Sort all the edges in non-decreasing order of their weight
    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), compare);

    // Allocate memory for creating V subsets
    struct subset* subsets = (struct subset*)malloc(V * sizeof(struct subset));

    // Initialize V subsets with single elements
    for (int v = 0; v < V; v++) {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }

    // Number of edges to be taken is equal to V-1
    while (e < V - 1 && i < graph->E) {
        // Pick the smallest edge
        struct Edge next_edge = graph->edge[i++];

        int x = find(subsets, next_edge.src);
        int y = find(subsets, next_edge.dest);

        // If including this edge does not cause cycle, include it in result and increment the index
        if (x != y) {
            result[e++] = next_edge;
            Union(subsets, x, y);
        }
    }

    // Print the constructed MST
    printf("Edge \tWeight\n");
    for (i = 0; i < e; ++i)
        printf("%d - %d \t%d\n", result[i].src, result[i].dest, result[i].weight);

    free(subsets);
}

int main() {
    int V, E;
    printf("Enter the number of vertices: ");
    scanf("%d", &V);

    printf("Enter the number of edges: ");
    scanf("%d", &E);

    struct Graph* graph = createGraph(V, E);

    printf("Enter source, destination, and weight for each edge:\n");
    for (int i = 0; i < E; ++i)
        scanf("%d %d %d", &graph->edge[i].src, &graph->edge[i].dest, &graph->edge[i].weight);

    KruskalMST(graph);

    return 0;
}

 

36. Write a Program to implement Kruskal’s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>

// Structure to represent an edge
struct Edge {
    int src, dest, weight;
};

// Structure to represent a node in the adjacency list
struct AdjListNode {
    int dest;
    int weight;
    struct AdjListNode* next;
};

// Structure to represent the adjacency list for a vertex
struct AdjList {
    struct AdjListNode* head;
};

// Structure to represent the graph
struct Graph {
    int V;
    int E;
    struct Edge* edges;
    struct AdjList* array;
};

// Structure to represent a subset for Union-Find
struct subset {
    int parent;
    int rank;
};

// Function to create a graph with V vertices
struct Graph* createGraph(int V, int E) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;
    graph->E = E;
    graph->edges = (struct Edge*)malloc(E * sizeof(struct Edge));
    graph->array = (struct AdjList*)malloc(V * sizeof(struct AdjList));
    for (int i = 0; i < V; ++i)
        graph->array[i].head = NULL;
    return graph;
}

// Function to create a new adjacency list node
struct AdjListNode* newAdjListNode(int dest, int weight) {
    struct AdjListNode* newNode = (struct AdjListNode*)malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// Function to add an edge to the graph
void addEdge(struct Graph* graph, int src, int dest, int weight, int e) {
    struct AdjListNode* newNode = newAdjListNode(dest, weight);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;

    graph->edges[e].src = src;
    graph->edges[e].dest = dest;
    graph->edges[e].weight = weight;
}

// Function to find the root of a given vertex
int find(struct subset subsets[], int i) {
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);
    return subsets[i].parent;
}

// Function to perform union of two subsets
void Union(struct subset subsets[], int x, int y) {
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);

    if (subsets[xroot].rank < subsets[yroot].rank)
        subsets[xroot].parent = yroot;
    else if (subsets[xroot].rank > subsets[yroot].rank)
        subsets[yroot].parent = xroot;
    else {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}

// Function to compare two edges based on their weights
int compare(const void* a, const void* b) {
    struct Edge* aEdge = (struct Edge*)a;
    struct Edge* bEdge = (struct Edge*)b;
    return aEdge->weight - bEdge->weight;
}

// Function to find the minimum spanning tree using Kruskal's algorithm
void KruskalMST(struct Graph* graph) {
    int V = graph->V;
    int E = graph->E;
    struct Edge* result = (struct Edge*)malloc((V - 1) * sizeof(struct Edge));
    int e = 0; // Index variable for result[]
    int i = 0; // Index variable for sorted edges

    // Sort all the edges in non-decreasing order of their weight
    qsort(graph->edges, E, sizeof(graph->edges[0]), compare);

    // Allocate memory for creating V subsets
    struct subset* subsets = (struct subset*)malloc(V * sizeof(struct subset));

    // Initialize V subsets with single elements
    for (int v = 0; v < V; v++) {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }

    // Number of edges to be taken is equal to V-1
    while (e < V - 1 && i < E) {
        // Pick the smallest edge
        struct Edge next_edge = graph->edges[i++];

        int x = find(subsets, next_edge.src);
        int y = find(subsets, next_edge.dest);

        // If including this edge does not cause cycle, include it in result and increment the index
        if (x != y) {
            result[e++] = next_edge;
            Union(subsets, x, y);
        }
    }

    // Print the constructed MST
    printf("Edge \tWeight\n");
    for (i = 0; i < e; ++i)
        printf("%d - %d \t%d\n", result[i].src, result[i].dest, result[i].weight);

    free(subsets);
}

int main() {
    int V, E;
    printf("Enter the number of vertices: ");
    scanf("%d", &V);

    printf("Enter the number of edges: ");
    scanf("%d", &E);

    struct Graph* graph = createGraph(V, E);

    printf("Enter source, destination, and weight for each edge:\n");
    for (int i = 0; i < E; ++i) {
        int src, dest, weight;
        scanf("%d %d %d", &src, &dest, &weight);
        addEdge(graph, src, dest, weight, i);
    }

    printf("Minimum Spanning Tree using Kruskal's Algorithm:\n");
    KruskalMST(graph);

    return 0;
}

 

37. Write a Program to implement Dijkstra’s algorithm to find shortest distance between two nodes of a user defined graph. Use Adjacency List to represent a graph
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>

int minDistance(int dist[], bool sptSet[], int V) {
    int min = INT_MAX, min_index;

    for (int v = 0; v < V; v++)
        if (sptSet[v] == false && dist[v] <= min)
            min = dist[v], min_index = v;

    return min_index;
}

void printSolution(int dist[], int V) {
    printf("Vertex \t\t Distance from Source\n");
    for (int i = 0; i < V; i++) {
        if (dist[i] == INT_MAX)
            printf("%d \t\t\t\t Infinite\n", i);
        else
            printf("%d \t\t\t\t %d\n", i, dist[i]);
    }
}

void dijkstra(int **graph, int src, int V) {
    int dist[V];
    bool sptSet[V];

    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;

    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, sptSet, V);

        sptSet[u] = true;

        for (int v = 0; v < V; v++)
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }

    printSolution(dist, V);
}

int main() {
    int V;
    printf("Enter the number of vertices in the graph: ");
    scanf("%d", &V);

    int **graph = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
        graph[i] = (int *)malloc(V * sizeof(int));

    printf("Enter the adjacency matrix of the graph (%d x %d):\n", V, V);
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    int src;
    printf("Enter the source vertex: ");
    scanf("%d", &src);

    dijkstra(graph, src, V);

    
    for (int i = 0; i < V; i++)
        free(graph[i]);
    free(graph);

    return 0;
}


 

 



38. Write a Program to implement Dijkstra’s algorithm to find shortest distance between two nodes of a user defined graph. Use Adjacency Matrix to represent a graph
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include <string.h>

typedef struct Node {
    int dest;           
    int weight;         
    struct Node* next;  
} Node;

typedef struct Graph {
    int V;          
    Node** array;   
} Graph;

Node* createNode(int dest, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->dest = dest;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

Graph* createGraph(int V) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->V = V;
    graph->array = (Node*)malloc(V * sizeof(Node));
    for (int i = 0; i < V; ++i)
        graph->array[i] = NULL;
    return graph;
}

void addEdge(Graph* graph, char* src, char* dest, int weight) {
    int srcIndex = src[0] - 'A';   
    int destIndex = dest[0] - 'A'; 

    
    Node* newNode = createNode(destIndex, weight);
    newNode->next = graph->array[srcIndex];
    graph->array[srcIndex] = newNode;

    
    newNode = createNode(srcIndex, weight);
    newNode->next = graph->array[destIndex];
    graph->array[destIndex] = newNode;
}

int minDistance(int dist[], bool sptSet[], int V) {
    int min = INT_MAX, min_index;

    for (int v = 0; v < V; v++)
        if (sptSet[v] == false && dist[v] <= min)
            min = dist[v], min_index = v;

    return min_index;
}

void printSolution(int dist[], int V) {
    printf("Vertex \t\t Distance from Source\n");
    for (int i = 0; i < V; i++) {
        if (dist[i] == INT_MAX)
            printf("%d \t\t\t\t Infinite\n", i);
        else
            printf("%d \t\t\t\t %d\n", i, dist[i]);
    }
}

void dijkstra(Graph* graph, int src) {
    int V = graph->V;   
    int dist[V];        
    bool sptSet[V];     
    
    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;

    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        
        int u = minDistance(dist, sptSet, V);

        sptSet[u] = true;

        Node* tmp = graph->array[u];
        while (tmp != NULL) {
            int v = tmp->dest;
            int weight = tmp->weight;
            if (!sptSet[v] && dist[u] != INT_MAX && dist[u] + weight < dist[v])
                dist[v] = dist[u] + weight;
            tmp = tmp->next;
        }
    }

    printSolution(dist, V);
}

int main() {
    int V, E;
    printf("Enter the number of vertices in the graph: ");
    scanf("%d", &V);

    Graph* graph = createGraph(V);

    printf("Enter the number of edges: ");
    scanf("%d", &E);

    printf("Enter the edges as source destination weight:\n");
    for (int i = 0; i < E; i++) {
        char src[2], dest[2];
        int weight;
        scanf("%s %s %d", src, dest, &weight);
        addEdge(graph, src, dest, weight);
    }

    char src[2];
    printf("Enter the source vertex: ");
    scanf("%s", src);
    int srcIndex = src[0] - 'A'; 

    dijkstra(graph, srcIndex);

    
    for (int i = 0; i < V; i++) {
        Node* tmp = graph->array[i];
        while (tmp != NULL) {
            Node* prev = tmp;
            tmp = tmp->next;
            free(prev);
        }
    }
    free(graph->array);
    free(graph);

    return 0;
}

 

39.WAP to implement Heap sort on 1D array of Student structure (contains student_name, student_roll_no, total_marks), with key as student_roll_no. And count the number of swap performed.

#include <stdio.h>

// Structure definition for Student
typedef struct {
    char student_name[50];
    int student_roll_no;
    int total_marks;
} Student;

// Function to swap two Student elements
void swap(Student* a, Student* b) {
    Student temp = *a;
    *a = *b;
    *b = temp;
}

// Function to heapify a subtree rooted with node i which is an index in arr[]
// n is the size of the heap
void heapify(Student arr[], int n, int i, int* swap_count) {
    int largest = i; // Initialize largest as root
    int left = 2 * i + 1; // left = 2*i + 1
    int right = 2 * i + 2; // right = 2*i + 2

    // If left child is larger than root
    if (left < n && arr[left].student_roll_no > arr[largest].student_roll_no)
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right].student_roll_no > arr[largest].student_roll_no)
        largest = right;

    // If largest is not root
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        (*swap_count)++; // Increment swap count
        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest, swap_count);
    }
}

// Function to perform Heap Sort
void heapSort(Student arr[], int n, int* swap_count) {
    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i, swap_count);

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        swap(&arr[0], &arr[i]);
        (*swap_count)++; // Increment swap count
        // Call max heapify on the reduced heap
        heapify(arr, i, 0, swap_count);
    }
}

// Function to print the array of Students
void printArray(Student arr[], int n) {
    for (int i = 0; i < n; i++)
        printf("Name: %s, Roll No: %d, Marks: %d\n", arr[i].student_name, arr[i].student_roll_no, arr[i].total_marks);
}

int main() {
    int n;
    printf("Enter the number of students: ");
    scanf("%d", &n);

    Student arr[n];
    for (int i = 0; i < n; i++) {
        printf("Enter details for student %d:\n", i + 1);
        printf("Name: ");
        scanf("%s", arr[i].student_name);
        printf("Roll No: ");
        scanf("%d", &arr[i].student_roll_no);
        printf("Total Marks: ");
        scanf("%d", &arr[i].total_marks);
    }

    int swap_count = 0;

    // Perform heap sort
    heapSort(arr, n, &swap_count);

    // Print sorted array
    printf("Sorted array:\n");
    printArray(arr, n);

    // Print the number of swaps performed
    printf("Total number of swaps performed: %d\n", swap_count);

    return 0;
}

 

40.WAP to implement Quick sort on 1D array of Employee structure (contains employee_name, emp_no, emp_salary), with key as emp_no. And count the number of swap performed.

#include <stdio.h>

// Structure definition for Employee
typedef struct {
    char employee_name[50];
    int emp_no;
    float emp_salary;
} Employee;

// Function to swap two Employee elements
void swap(Employee* a, Employee* b, int* swap_count) {
    Employee temp = *a;
    *a = *b;
    *b = temp;
    (*swap_count)++; // Increment swap count
}

// Function to partition the array and return the pivot index
int partition(Employee arr[], int low, int high, int* swap_count) {
    int pivot = arr[high].emp_no; // Pivot element (rightmost element)
    int i = (low - 1); // Index of smaller element

    for (int j = low; j <= high - 1; j++) {
        // If current element is smaller than the pivot
        if (arr[j].emp_no < pivot) {
            i++; // Increment index of smaller element
            swap(&arr[i], &arr[j], swap_count);
        }
    }
    swap(&arr[i + 1], &arr[high], swap_count);
    return (i + 1); // Return the index of pivot element
}

// Function to perform Quick Sort
void quickSort(Employee arr[], int low, int high, int* swap_count) {
    if (low < high) {
        // Partitioning index
        int pi = partition(arr, low, high, swap_count);

        // Recursively sort elements before and after partition
        quickSort(arr, low, pi - 1, swap_count);
        quickSort(arr, pi + 1, high, swap_count);
    }
}

// Function to print the array of Employees
void printArray(Employee arr[], int n) {
    for (int i = 0; i < n; i++)
        printf("Name: %s, Employee No: %d, Salary: %.2f\n", arr[i].employee_name, arr[i].emp_no, arr[i].emp_salary);
}

int main() {
    int n;
    printf("Enter the number of employees: ");
    scanf("%d", &n);

    Employee arr[n];
    for (int i = 0; i < n; i++) {
        printf("Enter details for employee %d:\n", i + 1);
        printf("Name: ");
        scanf("%s", arr[i].employee_name);
        printf("Employee No: ");
        scanf("%d", &arr[i].emp_no);
        printf("Salary: ");
        scanf("%f", &arr[i].emp_salary);
    }

    int swap_count = 0;

    // Perform Quick Sort
    quickSort(arr, 0, n - 1, &swap_count);

    // Print sorted array
    printf("Sorted array:\n");
    printArray(arr, n);

    // Print the number of swaps performed
    printf("Total number of swaps performed: %d\n", swap_count);

    return 0;
}

     

41.Assume that an array A with n elements was sorted in an ascending order, but two of its elements swapped their positions by a mistake while maintaining the array. Write a code to identify the swapped pair of elements and their positions in the asymptotically best possible time. [Assume that all given elements are distinct integers.]

#include <stdio.h>

// Function to identify the swapped pair of elements and their positions
void identifySwappedPair(int arr[], int n) {
    int first_swap_index = -1, second_swap_index = -1;

    // Traverse the array to find the points where the ascending order breaks
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            if (first_swap_index == -1) {
                first_swap_index = i;
            }
            second_swap_index = i + 1;
        }
    }

    // Print the swapped pair and their positions
    if (first_swap_index != -1 && second_swap_index != -1) {
        printf("Swapped pair: (%d, %d)\n", arr[first_swap_index], arr[second_swap_index]);
        printf("Positions: %d and %d\n", first_swap_index, second_swap_index);
    } else {
        printf("No swapped pair found.\n");
    }
}

int main() {
    int n;
    printf("Enter the number of elements in the array: ");
    scanf("%d", &n);

    int arr[n];
    printf("Enter the elements of the array: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Call the function to identify the swapped pair
    identifySwappedPair(arr, n);

    return 0;
}

 


42.Implement following hashing Techniques by assuming suitable input and Table Size. a. Linear Probing With Chaining Without Replacement Also mention number of collisions occurred while inserting a Data in hash table.

#include <stdio.h>
#include <stdlib.h>

#define TABLE_SIZE 10 // Define the size of the hash table
#define EMPTY -1      // Define the marker for empty slots

typedef struct {
    int data;
    int chain;
} HashEntry;

HashEntry hashTable[TABLE_SIZE];
int collisionCount = 0;

// Hash function
int hashFunction(int key) {
    return key % TABLE_SIZE;
}

// Initialize the hash table
void initializeTable() {
    for (int i = 0; i < TABLE_SIZE; i++) {
        hashTable[i].data = EMPTY;
        hashTable[i].chain = EMPTY;
    }
}

// Function to insert data into the hash table
void insert(int key) {
    int index = hashFunction(key);
    
    if (hashTable[index].data == EMPTY) {
        hashTable[index].data = key;
    } else {
        collisionCount++;
        int originalIndex = index;
        while (hashTable[index].data != EMPTY) {
            index = (index + 1) % TABLE_SIZE;
            if (index == originalIndex) {
                printf("Hash table is full!\n");
                return;
            }
        }
        // Insert the new key
        hashTable[index].data = key;
        
        // Update the chain
        int chainIndex = hashFunction(key);
        while (hashTable[chainIndex].chain != EMPTY) {
            chainIndex = hashTable[chainIndex].chain;
        }
        hashTable[chainIndex].chain = index;
    }
}

// Function to display the hash table
void displayTable() {
    printf("Index\tData\tChain\n");
    for (int i = 0; i < TABLE_SIZE; i++) {
        printf("%d\t%d\t%d\n", i, hashTable[i].data, hashTable[i].chain);
    }
}

int main() {
    int data, n;
    initializeTable();

    printf("Enter the number of elements to insert: ");
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("Enter data %d: ", i + 1);
        scanf("%d", &data);
        insert(data);
    }

    displayTable();
    printf("Number of collisions: %d\n", collisionCount);

    return 0;
}

 


43.Implement following hashing Techniques by assuming suitable input and Table Size. a. Linear Probing With Chaining With Replacement Also mention number of collisions occurred while inserting a Data in hash table.

#include <stdio.h>
#include <stdlib.h>

#define TABLE_SIZE 10 // Define the size of the hash table
#define EMPTY -1      // Define the marker for empty slots

typedef struct {
    int data;
    int chain;
} HashEntry;

HashEntry hashTable[TABLE_SIZE];
int collisionCount = 0;

// Hash function
int hashFunction(int key) {
    return key % TABLE_SIZE;
}

// Initialize the hash table
void initializeTable() {
    for (int i = 0; i < TABLE_SIZE; i++) {
        hashTable[i].data = EMPTY;
        hashTable[i].chain = EMPTY;
    }
}

// Function to insert data into the hash table
void insert(int key) {
    int index = hashFunction(key);
    
    if (hashTable[index].data == EMPTY) {
        hashTable[index].data = key;
    } else {
        collisionCount++;
        // If the current index contains an element with a different home position, replace it
        int currentIndex = index;
        int tempData = hashTable[currentIndex].data;
        int tempChain = hashTable[currentIndex].chain;

        if (hashFunction(tempData) != currentIndex) {
            hashTable[currentIndex].data = key;
            key = tempData;

            // Fix the chain of the displaced element
            int originalIndex = hashFunction(key);
            while (hashTable[originalIndex].chain != currentIndex) {
                originalIndex = hashTable[originalIndex].chain;
            }
            hashTable[originalIndex].chain = tempChain;
        }

        // Linear probing to find the next available slot
        while (hashTable[index].data != EMPTY) {
            index = (index + 1) % TABLE_SIZE;
        }
        
        // Insert the new key
        hashTable[index].data = key;

        // Update the chain for the original slot
        int chainIndex = hashFunction(key);
        while (hashTable[chainIndex].chain != EMPTY) {
            chainIndex = hashTable[chainIndex].chain;
        }
        hashTable[chainIndex].chain = index;
    }
}

// Function to display the hash table
void displayTable() {
    printf("Index\tData\tChain\n");
    for (int i = 0; i < TABLE_SIZE; i++) {
        printf("%d\t%d\t%d\n", i, hashTable[i].data, hashTable[i].chain);
    }
}

int main() {
    int data, n;
    initializeTable();

    printf("Enter the number of elements to insert: ");
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("Enter data %d: ", i + 1);
        scanf("%d", &data);
        insert(data);
    }

    displayTable();
    printf("Number of collisions: %d\n", collisionCount);

    return 0;
}



